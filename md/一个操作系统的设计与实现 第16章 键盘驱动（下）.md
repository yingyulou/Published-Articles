# 一个操作系统的设计与实现

# 第16章 键盘驱动（下）

我们的操作系统虽然已经实现了键盘驱动，但其功能仅限于在屏幕上打印输入的字符，任务并不能读取到这些字符。本章将要实现读取键盘输入的系统调用。

## 16.1 读取键盘输入的实现原理

想要让任务读取到键盘输入，比较简单的方案是构造一个数组，当键盘中断发生时，将键盘输入的字符保存在这个数组中。然而，这个方案有一个问题：如果一个任务想要读取键盘输入，但此时数组是空的，该怎么办？

想要解决这个问题，就需要一个具有阻塞功能的数组。当任务无法在数组中读取到字符时，将任务阻塞；当数组中又有字符时，将任务唤醒。处于阻塞中的任务不能运行，但也没有退出，所以，需要定义一个新的任务状态来描述这种情况。在我们的操作系统中，这种数组被称为IO缓冲区。

## 16.2 实现读取键盘输入

### 16.2.1 实现IO缓冲区

请看本章代码`16/Buffer.h`。

第6\~12行，定义了`Buffer`结构体。IO缓冲区的实现基于双指针算法，其内部包含一个16字节的字符缓冲区，以及两个索引值，`__leftIdx`是慢指针，用于读取字符，`__rightIdx`是快指针，用于存储字符。此外，IO缓冲区还包含一个TCB指针，用于记录在IO缓冲区上阻塞的任务。

接下来，请看本章代码`16/Buffer.hpp`。

`bufferInit`函数用于初始化IO缓冲区。

`bufferEmpty`函数用于判断IO缓冲区是否为空。如果慢指针和快指针相等，就说明无法从IO缓冲区取出字符。

`bufferFull`函数用于判断IO缓冲区是否已满。如果快指针已经紧跟在慢指针后面，就说明无法再向IO缓冲区存储字符。

`bufferPush`函数用于向IO缓冲区添加字符。

第29\~33行，如果IO缓冲区不是满的，则将新添加的字符写入快指针处，然后将快指针向右移动一格。

将一个字符写入IO缓冲区后，IO缓冲区一定非空，所以，如果先前有在IO缓冲区上阻塞的任务，此时就是唤醒它的时机。

第35\~39行，如果有任务在IO缓冲区上阻塞，则将其任务状态恢复到就绪状态。

`bufferPop`函数用于从IO缓冲区中取出一个字符。

第45\~51行，如果IO缓冲区为空，就说明暂时还无法取出字符。于是，将当前任务的任务状态修改为阻塞状态，然后将其记录在IO缓冲区中，然后立即发起任务切换。

第45行为什么要用`while`而不是`if`呢？这是因为，当唤醒任务时（第37行），只是修改了任务状态，而不是使任务瞬间开始继续执行。这就意味着，如果这个任务运气不好的话，IO缓冲区中新添加的字符又会被其他任务先行抢走，此时，如果不使用`while`，任务就会在被唤醒后直接向下执行，而此时的IO缓冲区是空的，这就造成了错误。这就是并行编程中的伪唤醒（Spurious wakeup）问题。

第53\~54行，从IO缓冲区中取出下一个字符，然后将慢指针向前推进。

第56行，返回取出的字符。

IO缓冲区的实现属于典型的生产者-消费者模型。生产者向IO缓冲区添加字符，并唤醒在IO缓冲区上阻塞的消费者；消费者从IO缓冲区中读取字符，并在无法读取时在IO缓冲区上阻塞。具体来说，IO缓冲区的生产者是键盘。当键盘中断发生时，键盘上按下的键被添加到IO缓冲区中；消费者是`inputStr`函数，这是一个系统调用函数，见下文。

### 16.2.2 升级任务切换过程

请看本章代码`16/Task.h`。

第7行，新增了任务阻塞状态。

请看本章代码`16/Task.hpp`。

第174\~176行，如果任务处于阻塞状态，则将其重新加入任务队列。

### 16.2.3 实现读取字符串系统调用

请看本章代码`Keyboard.hpp`。

第8行，定义了供键盘驱动使用的IO缓冲区。

`keyboardInit`是本章新增的函数，其用于初始化键盘驱动。

第48行，将ASCII码添加到IO缓冲区中。这个字符应该如何使用，由取出它的任务决定。

`inputStr`是本章新增的函数，其用于从键盘读取一个字符串。

第56\~59行，如果字符串为空，则不读取任何字符。

第61行，循环`strSize - 1`次，这是因为字符串的最后一个字符应强制设为0。

第63行，从IO缓冲区中取出一个字符，这一步可能导致任务阻塞。

第65行，将取出的字符写入结果字符串。

第67\~72行，如果当前字符是`\n`，则意味着输入已经结束了，此时，应将字符串的下一个字符置0，然后打印换行符并终止循环。

第73\~80行，如果当前字符是`\b`，则进行退格。这里需要注意溢出问题：仅当`idx`大于0时，才能进行退格。

第81\~85行，处理普通字符。

第88行，将字符串的最后一个字符置0。

接下来，请看本章代码`16/Int.s`。

第110行，在系统调用表中安装`inputStr`函数，其系统调用号为1。

接下来，请看本章代码`16/Kernel.c`。

第19行，初始化键盘驱动。

## 16.3 编译与测试

本章代码`16/Test.c`测试了1号系统调用。

