# 一个操作系统的设计与实现

# 第22章 快速系统调用

## 22.1 什么是快速系统调用

系统调用是操作系统为3特权级任务提供服务的一种手段。在32位操作系统中，我们通过中断实现了系统调用。由于系统调用是一个使用非常频繁的机制，且中断也不是专门为系统调用设计的，因此，64位CPU提供了系统调用的专用机制：快速系统调用。

快速系统调用的要点如下：

* 由专用的`syscall`指令发起，由专用的`sysret`指令返回
* `syscall`指令必须从3特权级转移到0特权级，`sysret`指令必须从0特权级返回到3特权级
* 使用寄存器传参
* 系统调用函数的CS:RIP是预设好的

综上，快速系统调用的整套机制都是非常固定的，这就带来了高效率。

## 22.2 快速系统调用的实现原理

在使用快速系统调用之前，需要先安装好快速系统调用所需的组件，这涉及到4个MSR。

### 22.2.1 IA32_EFER

快速系统调用这个功能在初始状态下是关闭的，其开关位于IA32_EFER的第0位。这个MSR我们已经见过了，它的编号是`0xc0000080`。

### 22.2.2 IA32_STAR

这个MSR的低32位是保留位，第32\~47位用于设定`syscall`指令使用的0特权级段选择子，第48\~63位用于设定`sysret`指令使用的3特权级段选择子。

段选择子的设定有一套比较奇怪的定义：

* 对于第32\~47位，其数值本身会被视为0特权级代码段选择子，这个数值加8会被视为0特权级数据段选择子
* 对于第48\~63位，其数值本身会被视为3特权级兼容模式代码段选择子，这个数值加8会被视为3特权级数据段选择子，这个数值加16会被视为3特权级IA32-e模式代码段选择子。`sysret`指令在执行时会选择其中一个代码段，选择方法将在下文中讨论

段选择子是描述符索引值左移3位得到的，所以将段选择子加8即为GDT中的下一个描述符。也就是说，第32\~47位设定的两个段选择子需要在GDT中连续，第48\~63位设定的三个段选择子需要在GDT中连续。不过，由于我们的操作系统从不使用兼容模式代码段，所以在GDT中并没有定义这个描述符。

这个MSR的编号是`0xc0000081`。

### 22.2.3 IA32_LSTAR

这个MSR用于设定系统调用函数的地址，其编号是`0xc0000082`。

### 22.2.4 IA32_FMASK

这个MSR用于设定RFLAGS屏蔽掩码。具体来说，当执行`syscall`指令时，RFLAGS会变成这样：`RFLAGS &= ~IA32_FMASK`。在我们的操作系统中，这个MSR用于屏蔽IF位，屏蔽掩码是`0x200`。

这个MSR的编号是`0xc0000084`。

## 22.2.5 `syscall`指令的行为

当执行`syscall`指令时，CPU会依次执行以下操作：

```c
RCX     = RIP
R11     = RFLAGS
CS      = IA32_STAR[32:47]
RIP     = IA32_LSTAR
RFLAGS &= ~IA32_FMASK
```

也就是说，RCX和R11会被`syscall`指令使用，它们不能用于传参。此外，`syscall`指令不会对RSP做任何处理，这是一个很重要的问题，我们将在下文中讨论。

## 22.2.6 `sysret`指令的行为

当执行`sysret`指令时，CPU会依次执行以下操作：

```c
RIP    = RCX
RFLAGS = R11
CS     = IA32_STAR[48:63] + (sysret指令没有64位前缀 ? 0 : 16)
```

也就是说：

1. 在系统调用期间，操作系统需要保护RCX和R11
2. `sysret`指令需要添加64位前缀，在nasm中，语法是：`o64 sysret`

## 22.3 实现快速系统调用

请看本章代码`22/Syscall.s`。

第11\~14行，将IA32_EFER的第0位置1，打开快速系统调用功能。

第16\~19行，设定IA32_STAR。在GDT中，3号描述符是0特权级代码段，4号描述符是0特权级数据段，这两个段描述符对应于IA32_STAR的第32\~47位；5号描述符是3特权级数据段，6号描述符是3特权级代码段，没有兼容模式代码段，所以，这里应将4号描述符安装到IA32_STAR的第48\~63位，使得5号和6号描述符处于正确的位置。

第21\~25行，将系统调用函数`syscallHandle`安装到IA32_LSTAR。

第27\~30行，将屏蔽掩码`0x200`安装到IA32_FMASK。

`syscallHandle`是系统调用函数。在32位操作系统中，系统调用由中断实现，中断发生时，CPU会自动切换到0特权级栈，由于0特权级栈是操作系统提供的，所以能够保证它的安全。那么，什么叫"安全的栈"？如果不切换栈，到底有什么问题？请看下例：

```c
void test()
{
    uint32_t n = 6;
    __asm__ __volatile__("syscall");
}
```

将这段代码翻译成汇编语言，可以是：

```asm
test:
	mov dword [rsp - 4], 6
	syscall
	ret
```

可以发现：这个函数的RSP没有减去4，此时如果发起系统调用，栈上的数字6就有可能被系统调用函数破坏掉。所以，在系统调用时，切换到一个安全的栈是有必要的。然而，`syscall`指令不会自动切换栈，我们需要手动完成这个操作。0特权级栈在TSS中，在切换前，需要先保存当前的RSP，TCB中的`__RSP3`字段就是为此需求准备的，其相对于IA32_GS_BASE的偏移量是104。

第36行，将3特权级栈保存到TCB中。

第37行，切换到0特权级栈。

第39\~40行，保护RCX和R11。现在的栈是安全的，可以放心使用。

第42\~43行，调用RAX指定的函数。

第45\~46行，恢复RCX和R11。

第48行，恢复3特权级栈。

第50行，从快速系统调用返回。

第52\~55行，定义了系统调用表。1号系统调用保留给后续章节使用。

接下来，请看本章代码`22/Kernel.c`。

第16行，初始化快速系统调用。

接下来，请看本章代码`22/Start.s`。

`_start`是3特权级任务的真正入口，其用于任务的自动退出。

## 22.4 编译与测试

本章代码`22/Makefile`新增了`Syscall.s`和`Start.s`的编译与链接命令。

本章代码`22/Kernel.c`和`22/Test.c`测试了0和2号系统调用。现在，任务已经可以自动退出了。

