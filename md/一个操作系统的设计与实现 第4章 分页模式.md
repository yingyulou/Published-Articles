# 一个操作系统的设计与实现

# 第4章 分页模式

## 4.1 分页模式的实现原理

### 4.1.1 引言

让我们以这幅图开始本章的内容：

![](../figure/os/4.1.png)

这是一段内存，每格为1字节，阴影部分的内存被占用。此时，如果加载一个4字节的程序，显然是做不到的。然而，此时的空闲内存其实是够4字节的，纯粹是因为内存不连续，导致无法加载。看来，问题的关键在于内存连续，如果有办法能让内存不连续，问题就解决了。但是，如果一个程序使用的内存是不连续的，那将是一件非常可怕的事情。我们习以为常的"一个数组就是一段连续内存"，甚至"一个整数由一小段连续内存构成"这样的结论通通要被推翻。所以，程序使用的内存必须是连续的。

综上，我们希望有这样的功能：

* 程序使用的内存是连续的
* 物理内存可以不连续

可以通过增加中间层的方法同时实现这两个需求。具体来说，可以构造一个数组，数组中存放的是内存地址。数组的索引值是连续的，而数组中存放的内存地址可以不连续。程序使用连续的索引值充当内存地址，而真正的内存地址需要通过这个数组获得。例如，可以给上述4字节程序提供以下数组：

```
[0, 1, 3, 4]
```

程序可以使用连续的内存地址0\~3，经过数组转换后，实际的内存地址依次是0、1、3、4。

甚至，这个数组还可以有多种设计方案：

```
[4, 3, 0, 1]
[3, 0, 4, 1]
...
```

无论这个数组怎么设计，程序使用的内存地址都是连续的0\~3，而实际的内存地址可以不连续。

使用这个方法后，程序使用的地址其实是假的，其被称为虚拟地址；数组中的地址才是真正的物理地址；这个数组被称为页表（Page Table）；数组中的值被称为页表项（Page Table Entry，PTE）；这种基于页表对地址进行转换的模式被称为分页模式（Paging mode）。分页模式解决了内存总量够用但不连续的问题。

### 4.1.2 页目录表、页表和页

32位CPU有32根地址线，最大支持4G内存。如果为这么多的内存构造一个页表的话，一个PTE是一个4字节的内存地址，4G个PTE就需要16G的页表。这是一个很离谱的结果：页表竟然比最大可用内存还大的多。造成这个结果的原因在于：PTE的粒度太小了，一个PTE只对应一字节内存，这就导致需要非常多的PTE才能把4G内存全部对应上。所以，如果扩大一个PTE对应的内存大小，就能减少PTE的数量。实际当中，一个PTE对应的内存大小是4096字节，即`0x1000`字节。一块`0x1000`字节的内存被称为一页（Page）。

如果以页作为单位构造页表，就需要`1 << 20`个PTE，此时，页表的大小减小到4M。这个大小在今天看来没什么，但是在80386那个年代，4M内存仍然是不可接受的，需要进一步减少页表的大小。

`1 << 20`的平方根是`1 << 10`，即1024。也就是说，一个具有`1 << 20`个PTE的页表，可以拆成1024个具有1024个PTE的页表。此时，可以再使用一张表，其中填入这1024个页表的地址，这样就得到了一个二级页表，其被称为页目录表（Page Directory Table）；页目录表中的值被称为页目录项（Page Directory Entry，PDE ）。

乍一看，引入页目录表是个负优化。本来有`1024 * 1024`个PTE，现在还要再加1024个PDE。然而，绝大多数程序使用的内存都很少，所以那些没有用到的内存所对应的页表都可以不存在，页表占用的内存也就大大降低了。

综上，想要从虚拟地址转换成物理地址，需要以下三个步骤：

1. 从页目录表中找到一个PDE，从中取得页表地址
2. 从页表中找到一个PTE，从中取得页地址
3. 将页地址加上偏移量，就得到了物理地址

进一步的：

1. 一个页目录表或页表都有1024个表项，每个表项的大小是4字节，所以，一个页目录表或页表的大小都是`0x1000`字节，即一页。所以，一页内存既可以存放数据，也可以存放一个页目录表或页表
2. 1024个表项可以用一个10位的二进制数作为其索引；页内偏移量可以用一个12位的二进制数表示。所以，页目录表索引、页表索引、页内偏移量加起来刚好是32位，和32位寄存器完美契合

### 4.1.3 虚拟地址

如前文所述，在分页模式下，32位的虚拟地址由以下三个部分组成：

![](../figure/os/4.1.png)

### 4.1.4 PDE和PTE

CPU规定：页地址必须是`0x1000`的整数倍，所以，页地址的低12位都是0。于是，PDE和PTE的低12位被"废物利用"了起来，如下图所示：

![](../figure/os/4.3.png)

P位是存在（Present）位。对于PDE来说，P位为0意味着页表不存在，这就是上文所说的"没有用到的页表都可以不存在"这一优化；对于PTE来说，P位为0意味着页不存在。反之，P位为1则意味着页表或页存在。

R/W位用于设定当前PDE或PTE中的内存是只读还是可读写。R/W位为0时，表示只读；R/W位为1时，表示可读写。在我们的操作系统中，此位全部设为1。

U/S位用于设定访问权限。U/S位为0时，只有0、1、2特权级能够访问该PDE或PTE中的内存；U/S位为1时，所有特权级都能访问这段内存。在我们的操作系统中，使用该位对3特权级进行访问限制。

A位和D位分别是访问（Access）位和脏页（Dirty）位。这两位都由CPU自动设置：当访问一个PDE或PTE中的内存时，设置A位为1；当修改一个PDE或PTE中的内存时，设置D位为1。在构造页目录表和页表时，应将这两位置0。

AVL位为可用（Available）位，我们的操作系统不使用这些位，将其置0。

此外，上图中省略了页级通写位等我们不使用的位。

### 4.1.5 CR3

页目录表是地址转换的起点，有了页目录表，才能得到页表地址，然后得到页地址，最后得到物理地址。所以，CPU专门为页目录表准备了一个控制寄存器CR3。在打开分页模式之前，需要将页目录表的物理地址安装到CR3中。和CR0一样，CR3只能和通用寄存器互相传送。

需要指出的是，CR3的低12位也用于一些功能的设定，但我们的操作系统并不使用这些功能，所以，CR3中存放的就是页目录表的物理地址。

### 4.1.6 CR0

分页模式的开关位于CR0的最高位上，当此位置1时，分页模式就打开了。所以，一定要在各项准备工作均已完成后，才能进行这一步。

## 4.2 分页和分段的关系

如果CPU同时启动了分段和分页模式，其地址转换过程是：分段在先，分页在后。也就是说，内存地址先通过`段基址 + 偏移地址`的方式产生，此地址被称为线性地址。如果分页模式未启用，则线性地址就是物理地址；如果分页模式启用，则线性地址会交由分页机制转换为物理地址。

我们的操作系统使用的是平坦模型，段基址为0，所以分段机制不会对内存地址造成任何影响。

## 4.3 进入分页模式

想要进入分页模式，就需要先安装好页目录表和页表。一旦进入分页模式，内存地址的含义就会瞬间发生改变。想要不发生混乱，就需要满足一个条件：目前正在使用的内存地址不能受分页模式影响，即：这些内存地址在分页模式下应转换到自身。具体来说，目前正在使用的是低端1M内存，所以，对于页目录表来说，只需要安装第一个PDE，将其指向第一个页表；对于第一个页表来说，需要安装前256个PTE。

由于低端1M内存已被使用，页目录表可以放在`0x100000`处，页表可以放在`0x101000`处。

请看本章代码`4/Mbr.s`。

第1\~24行和上一章一致，用于进入保护模式。

第26\~29行，清空页目录表和页表使用的内存，这样做将使所有PDE和PTE的P位都为0。两个表的总大小是`0x1000 + 0x1000 == 0x2000`，`stosd`指令一次处理4字节，故循环次数需要除以4。

第31行，在页目录表中安装第一个PDE，将其指向`0x101000`，属性为`0x3`，即页表存在，可读写，3特权级不允许访问。

第33\~41行，在页表中安装前256个PTE。EAX中存放的是页地址，属性为`0x3`，每次循环递增一页；EDI中存放的是PTE地址，每次循环递增4。

第43\~44行，将页目录表的物理地址安装到CR3。CR3只能和通用寄存器互相传送，所以不能使用`mov cr3, 0x100000`这样的指令。

第46\~48行，打开分页模式。在分页模式打开的一瞬间，内存地址的含义就发生了变化，不过，由于页目录表和页表的设定，这种变化对低端1M内存不产生任何影响。

第50\~51行，在分页模式打开后访问显存，以验证低端1M内存确实不受分页模式影响。

## 4.4 bochsdbg的使用

随着代码量的增加，出现错误也在所难免，此时，就需要使用bochsdbg了。

使用本章代码进入bochsdbg后，屏幕的左侧显示的是寄存器信息；中间是指令；右侧用于显示多种内容；下方则是命令输入和显示窗口。

bochsdbg的使用是基于命令的，以下讨论常见的一些命令。

### 4.4.1 b、lb

`b`命令用于以物理地址设置断点；`lb`命令用于以线性地址设置断点。例如：

```
b 0x7c00
```

在指令上双击也可以设置断点。

### 4.4.2 c

`c`命令将使代码继续执行，直至遇到了一个断点。

### 4.4.3 p或n

`p`或`n`命令等价，用于执行下一条指令，并且不进入函数体、`loop`指令等。

### 4.4.4 s

`s`命令也用于执行下一条指令，并且会进入函数体、`loop`指令等。

`s`命令可以后接一个数字，表示执行的指令数。

如果什么命令都不输入直接回车，也相当于执行了一次`s`命令。

### 4.4.5 blist、d

`blist`命令用于查看断点信息。在GUI的`View`菜单中也有显示断点信息的按钮。

`d`命令用于删除断点，其参数为断点的编号。例如：

```
d 1
```

### 4.4.6 r、sreg、creg

这三个命令分别用于查看通用寄存器，段寄存器，控制寄存器的信息。其内容比GUI中显示的更详细。

### 4.4.7 ?

`?`是一个内置的计算器，可以直接将寄存器作为表达式的一部分进行计算，有时候比较方便。例如：

```
? eax * 0x1000
```

### 4.4.8 print-stack

`print-stack`命令用于查看栈内存。在GUI中，也可以使用快捷键`F2`。

### 4.4.9 info gdt

`info gdt`命令用于查看GDT信息。在GUI中，也可以使用快捷键`Ctrl + F2`。

### 4.4.10 page

`page`命令用于查询一个虚拟地址对应的物理地址。例如：

```
page 0x7c00
```

### 4.4.11 info tab

`info tab`命令用于查看虚拟地址到物理地址的映射关系。在GUI中，也可以使用快捷键`Alt + F2`。

### 4.4.12 watch

`watch`命令用于监视内存的读写时机，当怀疑某块内存被错误读写时，可以使用这个命令。例如：

```
watch r 0x7c00        # 当读0x7c00地址时断点
watch w 0x7c00 0x200  # 当写0x7c00 ~ 0x7c00 + 0x200时断点
```

### 4.4.13 q

`q`命令用于退出调试器。

### 4.4.14 help

`help`命令用于查看bochsdbg支持的所有命令，也可以查看某个命令的具体说明。

### 4.4.15 魔法断点

代码中的`xchg bx, bx`指令会被视为断点，这就是bochsdbg提供的魔法断点功能。当难以确定断点的地址，但容易确定断点在代码中的位置时，这是一个非常有用的功能。

## 4.5 调试

使用本章代码启动bochsdbg后，首先看到的是MBR的第一条指令`lgdt [GDTR]`，其执行后，GDT就加载好了。于是，按下回车执行这条指令（相当于一次`s`命令），然后使用`info gdt`命令查看GDT信息，也可以使用快捷键`Ctrl + F2`，但显示的信息不如前者详细。

接下来值得关注的是第11行的`mov cr0, eax`指令。这条指令执行前后，分别用`creg`命令查看CR0，会发现CR0后面的`PE`从小写变成了大写，说明保护模式已经启动。

接下来的`jmp`指令同样值得关注。在这条指令执行前，可以发现其后的指令是不正确的，但跳转后就正确了，这说明此时的译码器已经切换到32位模式。

第48行的`mov cr0, eax`指令用于打开分页模式，这条指令执行后，使用`info tab`命令或快捷键`Alt + F2`查看虚拟地址和物理地址的映射关系，结果如下：

```
0x00000000-0x000fffff -> 0x000000000000-0x0000000fffff
```

这表明，低端1M内存的虚拟地址和物理地址是完全一致的。

事实上，计算机启动后执行的第一条指令并不是MBR的第一条指令，而是BIOS的第一条指令。但由于`~/.bochscmd`文件以及`-rc ~/.bochscmd`选项的存在，使得bochsdbg自动跳过了BIOS。

