# 一个操作系统的设计与实现

# 第5章 加载内核

一直以来，我们都在对MBR编程。MBR仅仅是一段512字节的程序，它最终的目标是加载操作系统内核，然后跳转到内核继续执行。本章将使用MBR加载一个由C语言编写的操作系统内核。

## 5.1 读写硬盘的实现原理

操作系统存储在硬盘中，现在需要将其读出到内存。想要读写硬盘，就需要依次进行以下操作：

1. 设定读写的扇区数
2. 设定起始扇区号
3. 发送读/写硬盘命令
4. 等待硬盘准备完毕
5. 读写硬盘

以下依次讨论这些步骤。

### 5.1.1 设定读写的扇区数

读写的扇区数需要写入`0x1f2`端口。这是一个8位端口，如果向此端口写入0，则扇区数被视为256；否则，扇区数就是写入的值。

### 5.1.2 设定起始扇区号

我们的操作系统使用的是具有28位逻辑扇区号的硬盘。然而，硬盘中用于存放逻辑扇区号的端口全都是8位的，所以，实际使用的是3个8位端口，加上1个8位端口的低4位，共同凑成28位的逻辑扇区号。这些端口如下表所示：

| 端口号  | 作用                                            |
| ------- | ----------------------------------------------- |
| `0x1f3` | 存放逻辑扇区号的0\~7位                          |
| `0x1f4` | 存放逻辑扇区号的8\~15位                         |
| `0x1f5` | 存放逻辑扇区号的16\~23位                        |
| `0x1f6` | 低4位存放逻辑扇区号的24\~27位，高4位固定为`0xe` |

### 5.1.3 发送读/写硬盘命令

`0x1f7`端口是一个既可读又可写的8位端口。如果向此端口写入数据，其用于接收命令。读硬盘的命令是`0x20`，写硬盘的命令是`0x30`。

### 5.1.4 等待硬盘准备完毕

硬盘接收到`0x20/0x30`命令后就会开始准备。在此期间，需要不断的读`0x1f7`端口以查询硬盘状态。对于读取到的8位整数，只需要关注其中的两位：

1. 如果第7位为1，表示硬盘忙，其他位都无效；如果第7位为0，表示硬盘不忙，其他位有效
2. 如果第3位为1，表示硬盘已经准备就绪；如果第3位为0，表示硬盘尚未准备就绪

综上，等待的目标是第7位为0且第3位为1。

### 5.1.5 读写硬盘

`0x1f0`端口用于读写硬盘，这是一个16位的端口。当硬盘准备完毕后，可以通过（大量的）`in/out`指令或`insw/outsw`指令进行读写。

## 5.2 编译内核

本章代码`5/Kernel.c`是用于测试的内核，其仅包含一个空循环。

内核在编译时不能依赖任何已有的库，且需要一些特殊设定。

请看本章代码`5/Makefile`。

第3行，将内核编译成静态库文件。在我们的操作系统中，会使用一些与C语言标准库重名的函数，`-fno-builtin`用于禁止GCC将这些函数优化成GCC自带的实现。`-fno-stack-protector`用于关闭栈保护器功能。

第4行，将库文件链接，得到可执行文件。`-Ttext-segment 0x0`用于设定内核在内存中的起始加载地址。事实上，最低1K内存中存储的是中断向量表，但我们并不使用这个表，所以可以直接覆盖这段内存。`-e main`用于设定入口符号，如果没有这个设置，链接器会提示`找不到_start`。读者可能会疑惑：C语言的入口点难道不是`main`函数吗？这个问题将在后续章节中讨论。此外，读者也可以将代码中的`main`改成`_start`，并去除`-e main`，也能通过链接。

第7行，将内核写入虚拟硬盘。在我们的操作系统中，内核使用97个扇区，与MBR使用的1个扇区，以及后续章节使用的2个扇区共同凑整到100个扇区。

## 5.3 ELF文件

Linux中，编译内核得到的`Kernel.o`和`Kernel`文件的格式都是ELF，即可执行与可链接格式（Executable and Linkable Format，ELF）。ELF格式适用于多种文件，包括静态链接库，动态链接库，可执行程序等，在我们的操作系统中，只需要关注可执行程序。

ELF文件的加载分为两个阶段，首先需要将整个文件读取到内存中，然后解析该文件，并按文件中提供的信息将程序加载到目的地址。

ELF文件的开头记录了一些信息，以下只列出和可执行程序有关的部分：

| 在文件中的偏移量 | 字节数 | 含义                     |
| ---------------- | ------ | ------------------------ |
| 0x0              | 1      | 魔数`0x7f`               |
| 0x1              | 3      | 字符串`ELF`              |
| ...              | ...    | ...                      |
| 0x18             | 4      | 入口地址                 |
| 0x1c             | 4      | 程序头在文件中的偏移量   |
| ...              | ...    | ...                      |
| 0x26             | 2      | 程序头表中每个表项的大小 |
| 0x28             | 2      | 程序头表中表项的数量     |
| ...              | ...    | ...                      |

程序头表中存放的是可执行程序的加载信息。其由一组表项构成，每个表项的结构如下：

| 相对于表项开头的偏移量 | 字节数 | 含义                     |
| ---------------------- | ------ | ------------------------ |
| 0x0                    | 4      | 类型                     |
| 0x4                    | 4      | 这段程序在文件中的偏移量 |
| 0x8                    | 4      | 这段程序需要加载到的地址 |
| ...                    | ...    | ...                      |
| 0x10                   | 4      | 这段程序在文件中的大小   |
| 0x14                   | 4      | 这段程序在内存中的大小   |
| ...                    | ...    | ...                      |

在我们的操作系统中，只需要关注类型为`0x1`的表项，这个类型表示可加载的程序段。

之所以要区分"这段程序在文件/内存中的大小"，是因为BSS段的存在。所以，加载一段程序时要分两步：

1. 使用"这段程序在文件中的大小"，将这段程序加载到目的地址中
2. 计算`这段程序在内存中的大小 - 这段程序在文件中的大小`，记作`N`，将`这段程序需要加载到的地址 + 这段程序在文件中的大小`后面的`N`字节清零，这样就完成了BSS段的加载

综上，加载并进入一个ELF文件需要以下步骤：

1. 将ELF文件从硬盘读取到内存中
2. 读取偏移量`0x1c`处的4字节整数，将其与ELF文件的起始地址相加，得到程序头表的起始地址
3. 读取偏移量`0x26`处的2字节整数，这是程序头表中每个表项的大小
4. 读取偏移量`0x28`处的2字节整数，这是程序头表中表项的数量
5. 遍历程序头表，将其中每一段类型为`0x1`的程序加载到目的地址中，并将BSS段清零
6. 跳转到偏移量`0x18`处的入口地址

## 5.4 防止MBR被内核覆盖

我们正在执行MBR中的指令，位于`0x7c00 ~ 0x7e00`之间，而内核是从`0x0`开始加载的。内核的大小不太可能小于`0x7c00`字节，所以，加载过程中的某个瞬间，MBR会被内核覆盖，从而突然出现奇怪的错误。此外，GDT也在MBR中，所以，即使内核加载完毕，MBR也不能被覆盖。

综上，想要解决这个问题，就需要在加载内核之前，将MBR抬升到较高的地址处。我们的操作系统选用`0x9e000`作为MBR的新地址。

## 5.5 加载内核

请看本章代码`5/Boot.inc`。

第4\~5行，定义了抬升后的MBR的段基址和物理地址。

接下来，请看本章代码`5/Mbr.s`。

第3行，删除了`vstart=0x7c00`。这是因为现在的MBR先后使用`0x7c00`和`0x9e000`两个起始地址，单一的`vstart=0x7c00`已经不能满足要求。

第5\~12行，将MBR从`0x7c00`复制到`0x9e000`，并将所有的段寄存器都切换到新的段基址上。

第16\~24行与上一章一致，用于进入保护模式。

第26行，使用32位远跳转指令进入保护模式。先前的MBR位于`0x7c00 ~ 0x7e00`之间，使用16位指令不会导致溢出，但现在的MBR位于`0x9e000 ~ 0x9e200`之间，必须使用32位指令才能避免溢出。

第28\~61行与上一章一致，用于进入分页模式。

第63\~65行，设定读取的扇区数为97。

第67\~80行，设定起始扇区号为1。

第82\~84行，发送读硬盘命令。此时，硬盘开始准备。

第86\~91行，不断读取`0x1f7`端口，以等待硬盘准备完毕。等待的目标已于上文中讨论过：第7位为0且第3位为1。

第93\~96行，将硬盘中的数据读出。参数如下：

* 端口号：`0x1f0`
* 目的地址：`0x80000`。这个地址离`0xa0000`有128K，是够用的
* 读取次数：`97 * 512 / 2`。读取的扇区数是97，一个扇区是512字节，`insw`指令一次读取2字节，所以可以使用这个公式计算读取次数

至此，ELF文件已经加载到`0x80000`处，接下来需要解析这个文件。

第98\~101行，读取ELF文件头中的多项信息，列举如下：

* EBX中存放的是程序头表地址。请注意：`0x8001c`处的数值是一个偏移量，其需要与`0x80000`相加才能得到内存地址
* EDX中存放的是程序头表中每个表项的大小
* ECX中存放的是程序头表中表项的数量

第105\~106行，判断表项的类型，只需要类型为`0x1`的表项。

第108\~113行，将这段程序加载到目的地址中，参数如下：

* ESI中存放的是源地址。这里同样需要注意：`[ebx + 0x4]`处的数值只是一个偏移量，其需要与`0x80000`相加才能得到内存地址
* EDI中存放的是目的地址
* ECX中存放的是这段程序的大小

第114\~118行，将BSS段清零。这里的EDI沿用了上面`rep movsb`指令的结果；ECX被设定为`[ebx + 0x14] - [ebx + 0x10]`。

第122\~123行，循环解析程序头表中的每个表项。

第125行，跳转到内核的入口地址。

第135行，手动计算GDT的起始地址。

至此，我们已经进入操作系统内核。

