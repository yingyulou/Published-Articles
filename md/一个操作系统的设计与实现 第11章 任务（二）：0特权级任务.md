# 一个操作系统的设计与实现

# 第11章 任务（二）：0特权级任务

在上一章中，我们的操作系统已经支持共享内核，这为任务的加载和运行做好了准备。

本章将要实现的是0特权级任务的加载与切换。

## 11.1 任务切换

### 11.1.1 协同式与抢占式任务切换

如果CPU上只运行着`Kernel.c`中的`main`函数，那么情况非常简单，只需要不断执行下一条指令即可。然而，如果现在有不止一个任务需要运行，CPU就需要在这几个任务之间不断切换，使每个任务都能得到运行的机会。那么，CPU在何时进行任务切换？又怎么进行任务切换呢？

最简单的任务切换方案被称为协同式任务切换。这种方案的运作方式为：操作系统提供一种任务切换的方法，各个任务均应在合适的时机主动使用这个方法，完成任务切换。协同式任务切换的优点是效率高且灵活，通过精心设计任务切换的时机，可以最大限度的利用CPU。但其缺点也很明显：这是一种非强制的方案，一个任务完全可以故意不进行任务切换，让CPU一直为自己服务。所以，任务切换最好是一个具有周期性和强制性的过程。时钟中断很适合被用于任务切换，这是因为，一方面，时钟中断的发起具有周期性；另一方面，外中断的发起具有强制性，不受任务的控制。所以，可以在时钟中断发生期间进行任务切换。这种由硬件强制进行的任务切换，被称为抢占式任务切换。

### 11.1.2 任务队列与任务控制块

想要实现任务切换，就需要有一个能存取任务的数据结构。当进行任务切换时，先将当前任务添加到此数据结构，再从中取出一个新任务，并切换到这个新任务。队列是实现任务切换的合适数据结构，其可使用链表实现。

在这个队列中，每个任务都是一个节点，这个节点由链表指针和其他信息构成，其被称为任务控制块（Task Control Block，TCB）。TCB的设计目标是：只要拿到TCB，就能得到这个任务的全部信息，且能切换到这个任务。

### 11.1.3 任务的执行环境

任务对任务切换的发生应当是无感知的。想要做到这一点，就需要在任务切换时，将当前任务的执行环境保存起来，以供将来恢复。

在我们的操作系统中，一个任务的执行环境包含以下内容：

* CS:EIP
* EFLAGS
* DS, ES, FS, GS
* 8个通用寄存器
* CR3

也就是说，只要操作系统能在任务切换时将这些内容保存好，任务就能在将来恢复到切换前的状态，且对此毫无感知。

中断发生时，CPU会自动将EFLAGS、CS、EIP压栈，然后进入中断处理函数。这意味着：任务的一部分信息已经保存在栈中了，所以，可以继续将4个数据段寄存器和8个通用寄存器压栈。栈段寄存器SS将在后续章节中讨论，本章假定其不会发生变化，所以无需压栈。

CR3可以保存在TCB中。那么，TCB在哪里呢？我们的操作系统使用以下设计：

* 使用一个全局变量记录当前任务的TCB
* 将任务的栈和TCB放置在同一页的两头，这样一来，只要任务进行了至少一次压栈（当中断发生后一定如此），就能通过`ESP & 0xfffff000`得到TCB的地址

至此，ESP就成了任务恢复的关键，只要拿到ESP，就能同时得到任务的栈和TCB，进而将任务恢复。所以，ESP的当前值也需要保存在TCB中。

综上，TCB中保存的信息如下：

1. `TCB + 0x1000`处是任务的栈顶。栈中保存有EFLAGS、CS、EIP、4个数据段寄存器和8个通用寄存器
2. CR3
3. ESP的当前值

### 11.1.4 任务切换的完整过程

任务切换的完整过程如下：

1. 由时钟中断发起任务切换
2. 将当前任务的4个数据段寄存器和8个通用寄存器压栈
3. 发送中断响应信号
4. 取得当前任务的TCB
5. 将ESP保存在TCB中
6. 将TCB添加到任务队列中
7. 从任务队列中取出新的TCB
8. 将ESP和CR3用新的TCB中的值覆盖
9. 将新任务的4个数据段寄存器和8个通用寄存器出栈

### 11.1.5 创建新任务

任务切换有一个隐含的前提：任务在切换时应当是正在运行或曾经运行过的，这样才谈得上切换。内核在任务切换时确实是正在运行的，但对于一个从来没有运行过的新任务，该怎么办呢？

一个巧妙的办法是：伪造新任务的TCB，使其好像是先前被切换过一样。这样，新任务就可以"混入"任务队列中了。具体来说，创建新任务分为以下几个步骤：

1. 分配2页，分别作为新任务的TCB和CR3
2. 将内核页目录表的第768\~1022项复制到新任务的CR3中，并将新任务的CR3的最后一个PDE指向其自己
3. 伪造新任务的栈。在任务切换时，栈顶从上往下依次是EFLAGS、CS、EIP、4个数据段寄存器和8个通用寄存器，一共`15 * 4`字节。所以，TCB中存放的ESP应设为`TCB地址 + 0x1000 - 15 * 4`。然后，在TCB的顶部填好这些寄存器的值，当新任务启动时，这些值就是各个寄存器的初始值
4. 此时，新任务和其他任务的TCB已经没有区别了，所以，将其添加到任务队列中

### 11.1.6 内核任务

内核本身也是一个任务，也需要参与任务切换，并且，由于内核确实是一个正在运行的任务，所以不需要伪造栈，只需要设置好CR3即可。

事实上，内核任务的TCB已经在上一章中准备好了，它位于`0xc009f000`。上一章`Mbr.s`中的`mov esp, 0xc00a0000`正是出于这个目的。

## 11.2 实现任务切换

### 11.2.1 任务队列

想要实现任务切换，就需要先实现一个队列，队列的底层可以使用链表实现。

队列的实现位于本章代码`11/Queue.h`和`11/Queue.hpp`中，其实现与普通链表相同。

### 11.2.2 初始化内核任务

请看本章代码`11/Task.h`。

第5\~10行，定义了TCB结构体。`TCB *`类型与`Node *`类型兼容。

接下来，请看本章代码`11/Task.hpp`。

第8行，定义了内核任务的TCB地址`0xc009f000`。

第10行，定义了当前任务的TCB，其指向内核任务。

第11行，定义了任务队列`__taskQueue`。任务切换时，当前任务会被添加到这个队列，新任务会从这个队列中取出。

`__kernelTaskInit`函数用于初始化内核TCB。

第15行，将内核页目录表的物理地址`0x100000`填入TCB。

`taskInit`函数用于初始化任务系统。

接下来，请看本章代码`11/Kernel.c`。

第25行，初始化任务系统。

### 11.2.3 创建新任务

请看本章代码`11/Task.hpp`。

`__getEFLAGS`函数用于取得EFLAGS的值。

`loadTaskPL0`函数用于创建新任务。

第39\~42行，分配2页。第1页用于新任务的TCB和栈，第2页用于新任务的CR3。

第43行，使用第8章中的公式计算得到CR3的物理地址。

第44行，使用上文中的公式计算得到新任务的栈顶。

第46\~47行，在新任务的TCB中安装CR3的物理地址和栈顶地址。

第49行，将内核页目录表的第768\~1022项复制到新任务的页目录表中。这里同样使用了第8章中的公式。

第50行，将新任务的页目录表的最后一项指向自己。

第52\~66行，伪造新任务的栈。需要注意的是：新任务的EFLAGS中的IF位（第9位）必须为1，用于打开外中断，否则，在第一次切换到新任务后，就不会再发生任务切换了。

第68行，将新任务的TCB添加到任务队列中。

第70行，返回新任务的TCB。

### 11.2.4 任务切换

请看本章代码`11/Task.hpp`。

`getNextTask`函数用于取得下一个任务的TCB。

第76行，将当前任务的TCB添加到任务队列。

第77行，从任务队列中取出下一个任务的TCB。

第79行，返回下一个任务的TCB。

接下来，请看本章代码`11/Int.s`。

`__intTimer`函数现在用于任务切换。

第51\~52行，将ESP存入当前任务的TCB中。

第54行，取得下一个任务的TCB。

第56\~57行，将CR3切换到新任务。

第59行，将ESP切换到新任务。

第61\~65行，将4个数据段寄存器和8个通用寄存器切换到新任务。

第67行，从时钟中断返回，将EFLAGS，CS，EIP切换到新任务。

## 11.3 编译与测试

本章代码`11/Kernel.c`以`__testTask`函数作为测试任务，并创建了两个测试任务。所以，输出结果中`Task`字符串的数量应为`Kernel`字符串的两倍。在打印字符串时使用了开关中断的指令，以避免由于任务切换而引发的错误。

我们的操作系统目前还不支持任务退出，所以，用于测试的任务不能退出。

