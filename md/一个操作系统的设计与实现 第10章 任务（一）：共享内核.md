# 一个操作系统的设计与实现

# 第10章 任务（一）：共享内核

一直以来，我们的操作系统在启动后，运行的都是`Kernel.c`中的`main`函数。只运行这一个函数是不够的，操作系统应当有能力加载并运行其他程序。

从本章开始，将使用四章的篇幅讨论操作系统如何加载并运行任务。这里的任务（Task）与进程（Process）是同义词，在操作系统领域中，任务这个词更为常用，请读者知悉。

## 10.1 内核地址空间与任务地址空间

不同任务使用的内存应当是互相不可见的，这种不可见体现在页目录表上，只要操作系统为每个任务构造不同的页目录表，就能将每个任务的虚拟地址映射到不同的物理地址上。然而，操作系统是一个被所有任务共享的资源，这包括操作系统提供的GDT、IDT、各种函数等，这部分内存应当是每个任务都可见的。

可以将4G虚拟地址空间分成两部分，一部分专用于操作系统，剩下的用于任务，然后，只要保证内核PDE在每个任务中都一样，就能实现操作系统的共享。所以，在创建每个任务时，需要将内核PDE复制到任务的页目录表中。

考察页分配器的实现：如果发现PDE不存在，就会分配一页，然后将页的物理地址与属性填入PDE。这一行为会导致页目录表被修改，而一旦页目录表发生修改，先前复制出去的内核PDE，就会和将来复制出去的内核PDE不同，这对于那些已经存在的任务来说是个隐患，一旦这些任务使用了新出现的PDE，就会因找不到PDE而引发错误。想要避免这个问题，就需要在打开分页模式之前填好内核的所有PDE，并初始化内核的所有页表。这样一来，无论将来怎么分配内存，内核的PDE都不会再发生改变。

在我们的操作系统中，4G虚拟地址空间的前3G供任务使用，最后1G供内核使用，所以，内核可用的虚拟地址从`0xc0000000`开始。1个页表能够映射4M内存，1G内存需要256个页表，又因为页目录表的最后一项并没有指向页表，所以只需要255个页表。1个页目录表和255个页表占用的内存刚好是1M，于是，可将其放置在`0x100000~0x200000`这段内存中。

## 10.2 重新组织内存

本章没有新增的模块，而是需要修改一些现有实现。

请看本章代码`10/Mbr.s`。

第41行，将循环次数修改为`0x100000 / 4`。现在整个1M内存都被清零，用于页目录表和页表。

第46\~54行，安装内核页目录表的第768\~1022个PDE，这些PDE指向的页表的物理地址从`0x101000`开始向后递增，页属性为`0x3`。这样一来，由于第0个PDE和第768个PDE指向的都是`0x101000`地址处的页表，所以从`0x0`开始的1M虚拟地址与从`0xc0000000`开始的1M虚拟地址是等价的。

在MBR中，以下三个地址需要抬升到内核地址空间：

1. GDT
2. ESP
3. EIP

第75\~76行，将GDT的起始地址抬升到内核地址空间，然后重新加载GDT。

第78行，将ESP修改为低端1M内存可用部分的最高处：`0xc00a0000`，此地址以下的一页是内核栈。这样设计的目的将在后续章节中讨论。

对EIP的修改将在稍后讨论。

第111行，115\~118行，127行，142行，将与ELF相关的地址抬升到内核地址空间。

EIP可由`jmp`指令修改，而142行的`jmp`指令读取的是ELF中的入口地址，其值由链接器决定。所以，只要修改链接命令，就能通过`jmp`修改EIP了。

接下来，请看本章代码`10/Print.hpp`。

第42行，51行，58\~59行，161行，将显存地址抬升到内核地址空间。

接下来，请看本章代码`10/Memory.hpp`。

第7行，将起始虚拟地址修改为`0xc0100000`。内核虚拟地址从`0xc0100000`开始可用。

接下来，请看本章代码`10/Makefile`。

第6行，将`-Ttext-segment 0x0`修改为`-Ttext-segment 0xc0000000`，从而在跳转到内核时，将EIP抬升到内核地址空间。

## 10.3 编译与测试

本章代码`10/Kernel.c`与`8/Kernel.c`一样，测试了修改后的内存管理系统与显卡驱动是否工作正常。

