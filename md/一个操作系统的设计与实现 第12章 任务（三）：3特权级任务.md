# 一个操作系统的设计与实现

# 第12章 任务（三）：3特权级任务

特权级是保护模式的核心概念之一，但我们的操作系统一直没有引入这个概念。这是因为，特权级只有在3特权级任务存在时才有意义。本章将要实现的是3特权级任务的加载与切换。

## 12.1 特权级

### 12.1.1 特权级的作用

特权级（Privilege Level），是保护模式中用于限制任务权限的机制。特权级有4级，分别是0\~3特权级。0特权级权限最大，供操作系统使用；3特权级权限最小，供普通任务使用。中间的两级在我们的操作系统中不使用。

特权级起到的作用如下：

1. **在不使用特殊机制的前提下**，禁止代码段寄存器切换特权级。也就是说，0特权级任务只能执行0特权级的代码，不能执行3特权级的代码；反之，3特权级任务只能执行3特权级的代码，不能执行0特权级的代码。这样，操作系统内部的代码就能得到保护，3特权级任务不能随意使用
2. **在任何情况下**，使用数据段寄存器只能访问平级或更低级的数据。也就是说，0特权级任务能够访问0特权级的数据，也能访问3特权级的数据；反之，3特权级任务只能访问3特权级的数据，不能访问0特权级的数据。这样，操作系统内部的数据就能得到保护，3特权级任务不能随意访问
3. EFLAGS的第12\~13位是IOPL（IO特权级）位，初值为0。只有特权级大于等于这两位，即数值上小于等于这两位的代码段才能执行`in`和`out`指令。我们的操作系统不修改这两位，因此，只有0特权级任务才有权限执行`in`和`out`指令。这样，IO端口就能得到保护，3特权级任务不能随意访问
4. 有少量非常关键的指令属于特权指令，这些指令**只有0特权级任务有权限执行**。在我们的操作系统中，特权指令包括以下几种：
   * `hlt`指令。显然，低特权级任务不能随意将CPU挂起
   * `sti`、`cli`指令，以及其他试图修改IF位的指令，如`popf`。低特权级任务不能关中断，否则抢占式任务切换就失效了
   * 试图修改IOPL的指令，如`popf`。低特权级任务不能修改IO特权级，否则对IO端口的保护机制就失效了
   * 试图修改控制寄存器、GDTR、LDTR（局部描述符表，在我们的操作系统中未使用）、IDTR、TR（见下文）的指令，如`mov cr0, eax`、`lgdt`等。这些指令对CPU有重大影响，例如，修改CR0能开关保护模式和分页模式，这显然不能供低特权级任务随意使用
   * `invlpg`指令。低特权级任务不能干预TLB

### 12.1.2 DPL，RPL与CPL

特权级由三部分组成：描述符特权级（Descriptor Privilege Level，DPL），请求特权级（Requested Privilege Level，RPL）和当前特权级（Current Privilege Level，CPL）。DPL位于描述符中，如段描述符，中断门等；RPL是段选择子的低2位；**CPL恒等于CS的RPL**。

CPL决定了当前任务的执行权限。上文中的"0特权级/3特权级任务"中的特权级，指的就是CPL。由于CPL恒等于CS的RPL，所以切换CS的过程，就是切换CPL的过程。

DPL决定了一个描述符的最低访问权限。向段寄存器加载段选择子时，CPU要求`CPL <= DPL && RPL <= DPL`。即，只有特权级平级，或更高级的指令才有权限访问此描述符。

RPL看上去是个没什么用的概念，如果没有RPL，CPL可以恒等于代码段的DPL；向段寄存器加载段选择子时，只需要`CPL <= DPL`即可。然而，RPL解决的是一个比较边缘的问题。设想：操作系统给3特权级任务提供了一个读硬盘函数，并要求3特权级任务提供数据段选择子以存放结果。此时，用户可以想办法猜到0特权级数据段选择子，并将其提供给操作系统，这样一来，3特权级任务就能读取0特权级数据了。给段选择子附加RPL后，即使3特权级任务故意把RPL写成0，操作系统也能将其改回来。正因为如此，CPL才由CS的RPL决定，而不是由代码段描述符的DPL决定。DPL只是一个最低标准，RPL才是准确的特权级。

### 12.1.3 特权级的提升

操作系统存在的意义是为3特权级任务提供服务。上文提到，数据段在任何情况下都不能被低特权级任务访问，但代码段不同，操作系统可以将一部分函数开放给3特权级任务使用，3特权级任务通过特权级升降机制使用这些函数：调用之前先升级，调用结束后再降级。

CPU提供的标准特权级升降机制是调用门（Call gate），但这种机制效率低下，所以，我们的操作系统，以及几乎所有的现代操作系统，都不使用这个机制。

事实上，中断门也有提升特权级的能力，因此，中断门可以用于向3特权级任务提供0特权级函数。具体步骤如下：

1. 发起一个中断
2. 检查`CPL <= DPL`（中断没有RPL）。如果通过，则允许任务进入中断门。**只有由指令发起的中断会进行这一步，外中断和CPU自己发起的中断无视中断门的DPL**
3. 检查`CPL >= 中断门中CS的RPL`，如果通过，则允许CS升级并调用中断门中的函数

综上，想要使用中断门，就必须满足两个条件：

1. 有权限进入中断门。这由中断门的DPL决定。这样做的目的是限制3特权级任务能够使用的中断门
2. 进入中断门后，必须发生升级或平级，不允许降级

### 12.1.4 0特权级栈、TSS与TSS描述符

在特权级切换时，CPU还有一个特殊要求：SS的RPL必须时刻等于CPL。这意味着，每个3特权级任务必须有两个栈，分别供0特权级和3特权级使用。当特权级发生切换时，栈也要跟着切换。0特权级栈需要放置在任务状态段（Task State Segment，TSS）中，TSS是一个至少104字节的表，结构如下：

![](../figure/os/12.1.png)

TSS（和任务门）是CPU提供的用于任务切换的标准机制，但我们的操作系统，以及几乎所有的现代操作系统，都不使用这个机制，TSS存在的唯一目的是提供0特权级栈。

TSS需要以TSS描述符的形式安装在GDT中。TSS描述符是系统段的一种，结构如下：

![](../figure/os/12.2.png)

TSS描述符中的B位，即忙（Busy）位，由CPU在加载TSS时自动置1，构造TSS描述符时应将其置0，其他位的含义同段描述符。

与GDT、IDT类似，CPU也为TSS提供了一个专用寄存器。不过，这个寄存器不叫TSSR，而是叫任务寄存器（Task Register，TR）。在TSS描述符安装到GDT中以后，需要使用`ltr TSS选择子`指令将TSS加载到TR，TSS选择子可以存放在16位寄存器或内存中。

当中断发生时，引入特权级概念后的过程如下：

1. 检查CPL是否有权限进入中断门
2. 检查中断门中的CS是否能使CPL升级或平级
3. 如果中断门中的CS与CPL平级，跳过此步骤；否则，暂存SS和ESP，然后将SS和ESP分别切换到TSS中的SS0和ESP0，再将暂存的SS通过高位补0的方式填充到32位后压栈，接着将暂存的ESP压栈
4. 将EFLAGS压栈，然后将EFLAGS的IF位清零
5. 将CS通过高位补0的方式填充到32位后压栈
6. 将EIP压栈
7. 跳转到中断门中的中断处理函数

上文提到，TSS"至少为104字节"。这是因为TSS还能提供一个被称为IO位图的功能，这个位图的位置由TSS中的IO位图基址指定。IO位图用于越过IOPL，单独开放某些IO端口的权限。如果IO位图基址大于等于TSS描述符中的TSS限长，则表示IO位图不存在。我们的操作系统不使用IO位图功能，因此，可将IO位图基址设置成103或`0xff`等更大的值。

### 12.1.5 特权级的降低

3特权级任务能够通过中断门提升特权级，但这毕竟是暂时的，在中断处理函数调用完成后，就需要回到3特权级。特权级的降低由`iret`指令实现，引入特权级概念后，该指令的执行过程如下：

1. 从栈中依次弹出EIP、CS、EFLAGS。如果弹出的CS的RPL为0，`iret`指令结束，否则，继续执行以下步骤
2. 依次检查DS、ES、FS、GS的RPL是否为3，如果不是，则将该段寄存器重置成0，指向GDT中的空描述符。这样做可以避免0特权级段选择子通过中断返回泄漏到3特权级任务中
3. 继续从栈中弹出ESP和SS，恢复到3特权级栈，因此，TSS中不需要存放3特权级栈，3特权级的SS和ESP位于0特权级栈中

## 12.2 3特权级任务的实现原理

### 12.2.1 3特权级代码段和数据段

GDT中需要安装一个3特权级代码段描述符，和一个3特权级数据段描述符，以供3特权级任务使用。这两个描述符除了DPL为3外，其他属性和0特权级描述符相同。

### 12.2.2 TSS

需要创建一个TSS，并在GDT中安装TSS描述符，并使用`ltr`指令加载这个TSS。

### 12.2.3 3特权级任务切换

3特权级任务切换也基于时钟中断，由于每个任务都有不同的ESP0，所以在任务切换时，需要修改TSS中的ESP0。SS0对于每个任务来说都是一样的，所以无需修改。

### 12.2.4 创建3特权级任务

与0特权级任务类似，创建3特权级任务也基于伪造栈技术，需要在栈上伪造17个寄存器的值。

3特权级任务不仅需要0特权级栈，还需要3特权级栈。在我们的操作系统中，3特权级栈为一页，其虚拟地址固定为`0xc0000000`向下的`0x1000`字节。

### 12.2.5 3特权级任务的加载和重定位

3特权级任务往往不是操作系统的一部分，而是由用户提供的，存放在硬盘上的一个程序，因此，需要进行加载时重定位。

平坦模型失去了重定位能力，重定位由分页模式以一种完全不同的方式实现。具体来说，编译器可以为程序提供一套虚拟地址，只要虚拟地址落在任务地址空间内即可。操作系统在加载任务时，不主动分配虚拟地址，而是使用ELF文件提供的虚拟地址，并为这些虚拟地址分配物理地址，并安装PDE、PTE，然后，将ELF文件中的程序段展开到这些虚拟地址中。

## 12.3 实现3特权级任务

### 12.3.1 添加3特权级段描述符、TSS描述符

请看本章代码`12/Mbr.s`。

第149\~151行，在GDT中添加三个新的段描述符，如下所示：

* 3特权级代码段描述符，段选择子是`(3 << 3) | 0x3`
* 3特权级数据段描述符，段选择子是`(4 << 3) | 0x3`
* TSS描述符，段选择子是`5 << 3`

TSS定义在内核TCB的后面，其地址是`0xc009f014`，下文将解释这个地址是怎么得到的。

### 12.3.2 在任务切换时修改ESP0

请看本章代码`12/Int.s`。

第63\~64行，将TSS中的ESP0修改成新任务的ESP0。TSS的地址是`0xc009f014`，ESP0在TSS中的偏移量是4。

### 12.3.3 系统调用

上文提到，可以使用中断将0特权级函数提供给3特权级任务使用。这个方案看似需要很多中断号，但是有更好的设计：构造一个函数表，其中存放的是操作系统为3特权级任务提供的函数。然后，只需要使用一个中断，其能够基于索引值选择并调用函数表中的某个函数。上述操作被称为系统调用，调用者提供的索引值被称为系统调用号。在我们的操作系统中，EAX用于存放系统调用号，EBX、ECX、EDX用于存放参数（如果有）。

请看本章代码`12/Int.s`。

`__intSyscall`是系统调用的中断处理函数。

第76\~78行，不管实际需要几个参数，都将EBX、ECX、EDX压栈。

第79行，使用EAX中存放的系统调用号调用对应的函数。

第80行，将栈恢复。

第82行，从系统调用中断返回。

第84\~85行，定义系统调用表。目前只支持一个系统调用：`printStr`函数，其系统调用号为0。

接下来，请看本章代码`12/Int.hpp`。

第27行，安装系统调用中断门。请注意：由于系统调用是给3特权级任务使用的，所以中断门的DPL必须是3，这样3特权级任务才有权限使用这个中断门。

### 12.3.4 修改内存管理系统

请看本章代码`12/Memory.hpp`。

`installTaskPage`是本章新增的函数，其用于在指定的虚拟地址处分配物理地址，并将虚拟地址与物理地址建立联系。

第66\~68行，计算得到起始页地址，结束页地址，以及页数。

第70行，为虚拟地址的每一页安装物理地址。

### 12.3.5 初始化TSS

请看本章代码`12/Task.h`。

第10行，声明了一个保留给后续章节的数据成员。

第11行，声明了TSS。请注意：这个数据成员只对内核任务有效。内核任务的TCB位于`0xc009f000`，`__TSS`成员的偏移量是`0x14`，所以，TSS的地址是`0xc009f014`。

接下来，请看本章代码`12/Task.hpp`。

第18\~20行，初始化TSS中的SS0和IO位图基址。内核用不到ESP0，所以无需初始化。

第22行，加载TSS。

### 12.3.7 加载3特权级任务

请看本章代码`12/Task.hpp`。

`loadTaskPL3`是本章新增的函数，其用于加载3特权级任务。

不同于`loadTaskPL0`函数，`loadTaskPL3`函数的参数是硬盘的起始扇区号和扇区数。所以，此函数可以一步到位的从硬盘上加载3特权级任务。

第83\~95行与`loadTaskPL0`函数的开头部分一致。用于分配新任务的TCB和CR3，并设置好新的CR3。

第97\~102行，保存内核任务的CR3，然后暂时切换到新任务的CR3。这样做的目的是：使用新任务的页目录表和页表进行后续内存分配。请注意：这里的内联汇编使用了第6章讨论的独占约束`=&r`。

第104\~106行，将任务从硬盘读取到ELF缓冲区。

第108\~111行，读取ELF文件头中的以下信息：

* 入口地址
* 程序头表地址
* 程序头表中每个表项的大小
* 程序头表中表项的数量

第113行，遍历程序头表中的每个表项。

第115行，判断当前表项的类型，只关注类型为`0x1`的表项。

第117\~120行，读取程序头表中的以下信息：

* 程序段的源地址
* 程序段的目的地址
* 程序段在文件中的大小
* 程序段在内存中的大小

第122行，在ELF要求的加载地址处安装页。由于`installTaskPage`函数会将内存清零，所以，BSS段无需单独处理。

第123行，加载程序段到目的地址。

第127\~143行，伪造3特权级任务的0特权级栈。

第145行，在`0xc0000000 - 0x1000`地址处安装3特权级栈。

第147行，将内核任务的CR3换回。

第149行，将新任务添加到任务队列中。

## 12.4 编译与测试

请看本章代码`12/Test.c`。

这个任务是本章的测试任务，其运行在3特权级下，所以没有权限使用内核中的函数，唯一能用的是0号系统调用。使用系统调用还有一个好处：由于系统调用是中断，而中断过程中不会发生任务切换，所以系统调用是自带锁的。

第3\~6行，在循环中不断发起0号系统调用，打印`Task`字符串。

我们的操作系统仍然不支持任务退出，所以任务不能退出。

接下来，请看本章代码`12/Makefile`。

第6行，编译`Test.c`。

第8行，链接`Test.o`。程序段的起始加载地址是0。

第12行，将`Test`写入虚拟硬盘。起始扇区号是1000。

接下来，请看本章代码`12/Kernel.c`。

第16\~17行，将测试任务加载两次。

第21\~24行，在循环中不断发起0号系统调用，打印`Kernel`字符串。

## 12.5 调试

本章的测试任务运行在3特权级下，此时，如果想手动进行任务切换，就需要将`__idtInit`函数中的`0x8e00`修改成`0xee00`，使得3特权级任务也能进入`0x20`号中断门。

在bochsdbg中，可以使用`info tss`命令查看TSS。

