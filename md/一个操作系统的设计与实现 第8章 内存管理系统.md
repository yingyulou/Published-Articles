# 一个操作系统的设计与实现

# 第8章 内存管理系统

计算机上的任何程序，包括操作系统自己，都需要使用内存。所以，操作系统需要实现内存管理系统，以进行内存的分配和回收。

在我们的操作系统中，内存管理系统由两部分组成：页分配器和页回收器。本章将实现这两个部分。

## 8.1 从虚拟地址到物理地址

回顾CPU对内存地址的转换过程：

1. 使用段寄存器中的段选择子，在GDT中找到一个段描述符，从中取得段基址
2. 将段基址与偏移地址相加，得到虚拟地址
3. 取CR3中的页目录表地址，并取虚拟地址的最高10位作为页目录表索引值，从页目录表中取得页表地址
4. 取虚拟地址的中间10位作为页表索引值，从页表中取得页地址
5. 取虚拟地址的最低12位，将其与页地址相加，得到物理地址

我们的操作系统使用的是平坦模型，所有的段基址都是0，所以上述第1、2步对地址没有任何影响。

当分配新的虚拟页地址时，上述第3、4步都有可能找不到页表（PDE的P位为0）或页（PTE的P位为0）。当PDE的P位为0时，需要分配一页作为页表，并将其物理地址和属性填入PDE；当PTE的P位为0时（对于新分配的虚拟页来说一定如此），需要分配一页，并将其物理地址和属性填入PTE。这样一来，从虚拟地址到物理地址的转换就畅通了。

另一方面，无论是虚拟页地址还是物理页地址，怎么知道哪些地址是可用的呢？这就需要构造两个布尔数组，分别用于记录虚拟页地址和物理页地址的使用情况。布尔数组在实现上可以使用位图优化。

分页模式的特点是：虚拟地址连续而物理地址可以不连续。于是，在分配虚拟地址时，需要找N页连续可用的地址；在分配物理地址时，可以分N次进行，每次找一页可用的地址，然后将虚拟地址与物理地址建立联系。

综上，想要分配N页内存，需要依次进行以下步骤：

1. 在虚拟地址位图中找到N个连续可用位，将其设定为已使用。将找到的位图索引转换为虚拟页地址
2. 循环N次，每次在物理地址位图中找到1个可用位，将其设定为已使用。将找到的位图索引转换为物理页地址，然后，将当前的虚拟页地址与物理页地址建立联系

同理，想要回收N页虚拟内存，需要依次进行以下步骤：

1. 将虚拟页地址转换为位图索引，将虚拟地址位图中的对应位设定为未使用
2. 循环N次，每次从当前虚拟页地址得到物理页地址，将其转换为位图索引，将物理地址位图中的对应位设定为未使用。然后，将当前虚拟页地址对应的PTE清零

## 8.2 PDE和PTE的虚拟地址

想要在虚拟地址和物理地址之间建立联系，就需要设定虚拟地址对应的PDE和PTE。那么，PDE和PTE的地址是什么呢？

这个问题乍一看很简单：页目录表地址在CR3中，而PDE和PTE的索引值在虚拟地址中，只需要将其取出，手动完成查找PDE和PTE的过程，就可以了。这样做的问题是：分页模式下，所有的地址都是虚拟地址，而CR3、PDE、PTE中存放的都是物理地址，就算已知页目录表的地址是`0x100000`，页表的地址是`0x101000`，也不能使用这两个物理地址，必须使用虚拟地址。

事实上，只需要一行精妙的代码就能解决这个问题，它位于本章代码`8/Mbr.s`的第45行：

```asm
mov dword [0x100ffc], 0x100003
```

这行代码将页目录表的最后一个PDE指向页目录表本身。这样做有什么用呢？再次回顾从虚拟地址到物理地址的转换过程，其**必须**经历三个步骤：

1. 找到一个PDE，取得其中的页表地址
2. 找到一个PTE，取得其中的页地址
3. 将页地址与偏移地址相加，得到物理地址

现在需要的是PDE和PTE的地址，即第1步和第2步的结果。但上述三个步骤是不能暂停，也不能去除的。不过，由于最后一个PDE指向的是页目录表本身，如果使用这个PDE，就能在页目录表中空兜一次，从而消耗掉一个步骤。

具体来说，如果虚拟地址的最高10位全为1，那么上述过程就会变成这样：

1. 空兜
2. 找到一个PDE，取得其中的页表地址
3. 将页表地址与偏移地址相加，得到PTE地址

进一步的，如果虚拟地址的最高20位全为1，那么上述过程就会变成这样：

1. 空兜
2. 空兜
3. 将页目录表地址与偏移地址相加，得到PDE地址

综上，我们得到了以下公式：

* `PDE地址 == 0xfffff000 | (虚拟地址 >> 22 << 2)`
* `PTE地址 == 0xffc00000 | (虚拟地址 >> 12 << 2)`

## 8.3 实现内存管理系统

### 8.3.1 实现位图

想要实现内存管理系统，就需要先实现位图。

请看本章代码`8/Bitmap.h`。

第5\~8行，定义了位图结构体。位图不进行边界检查，所以其不持有位图的大小。

接下来，请看本章代码`8/Bitmap.hpp`。

`bitmapInit`函数用于初始化位图。

`__bitmapGet`函数和`__bitmapSet`函数分别用于读取位和设置位。

`bitmapAllocate`函数用于分配一段连续的位。实现中，0表示可用而1表示不可用。所以，当找到一段连续的0后，应将这些0转变为1。

`bitmapDeallocate`函数用于回收一段连续的位。

### 8.3.2 实现页分配器

请看本章代码`8/Memory.hpp`。

第7行，定义了虚拟地址的分配起点，这是一个随便写的地址，只要大于等于`0x100000`即可。

第8行，定义了物理地址的分配起点，这个地址需要大于等于`0x102000`，因为`0x100000`的前两页已经被使用了。

第10行，定义了两个位图。`__vBitmap`供虚拟地址使用，`__pBitmap`供物理地址使用。

第11行，定义了上述两个位图的数据区。在我们的操作系统中，由于不考虑物理内存的实际大小，故物理内存位图固定使用一页；虚拟地址空间的理论大小为4G，但出于简化考虑，实现中也只使用一页位图。一页位图可以管理`0x8000`个页，即128M内存。

`memoryInit`函数用于初始化上述两个位图。

`__allocateAddr`函数用于分配地址。其先调用`bitmapAllocate`函数以分配位，然后将得到的位图索引转换为地址。

`__installPage`函数用于在虚拟地址与物理地址之间建立联系。

第28\~29行，使用上文中的公式取得PDE指针和PTE指针。

第31行，判断PDE的P位，如果为0，说明当前虚拟地址没有对应的页表，此时需要分配一页，并将其物理地址和属性填入PDE。

第33行，分配一页，并将其物理地址和属性填入PDE。这里使用的页属性是`0x7`，表示存在、可读写、所有特权级均可访问。

第34行，将新分配的页表清零。页表的虚拟地址可由PTE地址去除偏移量得到。

第37行，将页的物理地址和属性填入PTE。这里使用的页属性也是`0x7`。

第39行，执行`invlpg (虚拟内存地址)`指令。CPU内部为虚拟地址到物理地址的转换提供了缓存，其被称为快表（Translation Lookaside Buffer，TLB）。然而，如果页目录表或页表发生了变化，与之相关的TLB缓存就失效了，但CPU作为缓存的使用者，无法感知到此事。因此，CPU要求操作系统在修改页目录表和页表时主动刷新TLB。

刷新TLB的方法有两种：

1. 加载CR3。这样做将直接清空整个TLB
2. 使用`invlpg (虚拟内存地址)`指令。这样做将刷新这个虚拟地址的TLB缓存（如果有）

`__installMemory`函数用于安装连续多个虚拟页。

第45\~48行，循环`pageCount`次，每次分配一页物理地址，并将其与虚拟地址建立联系。

第50行，将分配得到的内存清零。

`allocateKernelPage`函数用于分配内核页。

第56行，分配`pageCount`页虚拟地址。

第58行，为虚拟地址的每一页安装物理地址。

第60行，返回分配到的虚拟地址。

接下来，请看本章代码`8/Kernel.c`。

第11行，初始化内存管理系统。

### 8.3.3 实现页回收器

请看本章代码`8/Memory.hpp`。

`__deallocateAddr`函数用于将待回收的页地址转换为位图索引，然后将其从位图中删除。

`deallocateKernelPage`函数用于回收内核页，其实现步骤与`allocateKernelPage`函数完全相反。

第74行，将虚拟页地址从位图中删除。

第76行，循环`pageCount`次，每次循环回收一页物理地址，并断开虚拟地址与物理地址之间的联系。

第78行，计算得到当前的虚拟页地址。

第79行，使用上文中的公式取得PTE指针。

第80行，读取PTE，并去除低12位上的属性，这样就得到了当前页的物理地址。

第82行，将物理页地址从位图中删除。

第84\~85行，断开虚拟地址与物理地址之间的联系。

### 8.3.4 杂项

请看本章代码`8/Mbr.s`。

第45行，将页目录表的最后一个PDE指向页目录表自己的物理地址。这样做的意义已经在上文讨论过。

接下来，请看本章代码`8/Int.s`。

在上一章中，`intTimer`函数包含了一段打印数字的代码，在本章中已经将其删除。

接下来，请看本章代码`8/Util.hpp`。

第5\~24行，实现了`memcpy`和`memset`函数。

## 8.4 编译与测试

本章代码`8/Kernel.c`测试了内存管理系统，请读者自行分析输出结果。

