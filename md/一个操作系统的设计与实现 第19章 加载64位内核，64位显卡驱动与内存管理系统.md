# 一个操作系统的设计与实现

# 第19章 加载64位内核，64位显卡驱动与内存管理系统

## 19.1 64位ELF格式

在64位模式下，由于内存地址变宽，ELF格式中的内存地址也要跟着变宽。这并不是一个麻烦的问题，因为ELF格式的整体结构没有发生变化，仍然由一个文件头，加上若干程序头表组成。

对于64位ELF格式的文件头，我们需要关注的信息如下表所示：

| 偏移量 | 字节数 | 含义                        |
| ------ | ------ | --------------------------- |
| `0x18` | 8      | 程序入口地址                |
| `0x20` | 8      | 程序头表在ELF文件中的偏移量 |
| `0x36` | 2      | 程序头表中每个表项的大小    |
| `0x38` | 2      | 程序头表中表项的数量        |

对于64位ELF格式的程序头表项，我们需要关注的信息如下表所示：

| 偏移量 | 字节数 | 含义                         |
| ------ | ------ | ---------------------------- |
| `0x0`  | 4      | 表项类型，1为可加载的段      |
| `0x8`  | 8      | 当前段在文件中的偏移量       |
| `0x10` | 8      | 当前段需要被加载到的虚拟地址 |
| `0x20` | 8      | 当前段在文件中的大小         |
| `0x28` | 8      | 当前段在内存中的大小         |

## 19.2 加载内核

请看本章代码`19/Mbr.s`。

第90\~123行，读取硬盘的1\~97号扇区，并加载到`0x80000`处。

第125\~128行，从ELF文件头中读取并计算程序头表的地址，表项的大小和数量。这些地址立即数都没有超过32位，所以是可以直接使用的。

第130\~150行，读取每个程序头表项，并将其中的段展开到目标位置。这部分的实现思路与32位操作系统一致，这里不再赘述。

第152行，跳转到内核。同样的，地址立即数没有超过32位，所以是可以直接使用的。

## 19.3 64位显卡驱动

请看本章代码`19/Util.h`。

第18\~21行，定义了`va_xxx`系列宏。64位GCC使用的是System V AMD64 ABI，该ABI混合使用寄存器与栈传参，笔者不清楚如何在不借助编译器内建函数的前提下实现这套功能。

`19/Util.h`的剩余部分，以及本章代码`19/Util.hpp`的实现思路与32位操作系统一致，这里不再赘述。

64位显卡驱动的实现位于本章代码`19/Print.h`和`19/Print.hpp`中，其实现思路与32位操作系统一致，仅在实现细节上有以下区别：

* `0xb8xxx`的虚拟地址是`0xffff8000000b8xxx`
* 64位模式下可以使用`movsq/stosq`指令，一次操作8字节
* `printInt`函数，`printHex`函数，以及`printf`的`%x`用于打印64位无符号整数，可用于打印指针

## 19.4 64位内存管理系统

想要实现内存管理系统，就需要先实现位图。位图的实现位于本章代码`19/Bitmap.h`和`19/Bitmap.hpp`中，其实现思路与32位操作系统一致，这里不再赘述。

64位内存管理系统的实现位于本章代码`19/Memory.h`和`19/Memory.hpp`中，其实现思路与32位操作系统一致，仅在实现细节上有以下区别：

* 内核虚拟地址的分配起点是`0xffff800000200000`
* 四级分页模式下，虚拟地址转换的步骤更多，各种表的地址需要反复利用最后一个PML4E进行空兜。建议读者使用带二进制功能的计算器构造与检查函数中用到的各种掩码

## 19.5 编译与测试

请看本章代码`19/Makefile`。

第3行，编译内核。`-mcmodel=large`选项用于启用64位地址模式。

第4行，链接内核。`-N`选项用于关闭段对齐；代码段的起始虚拟地址为`0xffff800000000000`，即物理地址`0x0`。

本章代码`19/Kernel.c`测试了显卡驱动和内存管理系统。

