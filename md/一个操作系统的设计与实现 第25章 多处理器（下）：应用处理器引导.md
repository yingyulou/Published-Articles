# 一个操作系统的设计与实现

# 第25章 多处理器（下）：应用处理器引导

## 25.1 应用处理器

当计算机启动时，不管其中有多少个CPU，都只有一个CPU会真正启动，这个CPU被称为引导处理器（Bootstrap Processor，BSP），其他CPU会等待被BSP唤醒，这些CPU被称为应用处理器（Application Processor，AP）。

BSP可以在任意时刻向所有AP广播唤醒信号，当AP接受到信号后，就会启动BIOS，随后跳转到操作系统为其准备的引导程序处继续执行。具体来说，唤醒功能由LAPIC提供，想要唤醒AP时，BSP应先向`0xfee00300`发送固定的`0x000c4500`，再向同一地址发送`0x000c4600 | AP引导程序的第12~19位`。需要指出的是：笔者发现在bochs中，这两次发送不能连续进行，需要在中间添加一条"跳转到下一行"的指令，这可能是bochs的bug。"跳转到下一行"的机器语言为：`db 0xeb, 0x0`。

综上，AP引导程序需要满足以下两个要求：

1. 只能使用20位内存地址
2. 对齐到`0x1000`

在我们的操作系统中，AP引导程序位于硬盘的97号扇区，伴随内核一起加载，刚好能加载到`0x8c000`地址处，能够同时满足上述两个要求。

唤醒AP的时机是可以自由选择的，这意味着：AP引导程序可以使用各种现成的组件，如PML4、GDTR、IDTR等，这就使得AP引导程序是BSP引导过程的简化版。

## 25.2 LAPIC的开关

默认状态下，只有BSP的LAPIC是打开的，可以直接使用，而AP的LAPIC是关闭的。LAPIC的开关位于`0xfee000f0`地址处的第8位，将其置1即可打开LAPIC。

## 25.3 AP的自我识别

每个CPU都有一个编号，BSP的编号是0，AP的编号从1开始向后顺延。编号由LAPIC提供，其位于`0xfee00020`地址处的第24\~31位。

## 25.4 引导AP前的准备

每个CPU的寄存器是独立的，但内存是共享的，所以，PML4，GDT，IDT等位于内存中的组件均可在CPU之间共享，而GDTR，IDTR可使用`sgdt/sidt`指令存入内存后共享。

TSS用于获取任务的0特权级栈，由于每个CPU都会运行一个任务，所以TSS不能在CPU之间共享，应该为每个CPU分别安装一个。

请看本章代码`25/Task.hpp`。

第9行，定义CPU的数量为4。我们的操作系统固定使用1个BSP和3个AP。

第11行，定义AP的0特权级栈。这些栈地址必须对齐到页边界。

第12行，延长GDT的大小，以容纳每个AP的TSS描述符。

第45\~56行，初始化每个AP的内核任务TCB和TSS，并在GDT中安装TSS描述符。

## 25.5 实现AP引导程序

AP的引导是在操作系统启动后期才开始的，此时的操作系统处于IA32-e模式，但AP处于实模式，所以，AP的引导分为两阶段进行：

* 第一阶段：利用现成的GDT和PML4快速进入IA32-e模式。这一阶段的引导程序是独立的，其位于`0x8c000`地址处
* 第二阶段：在IA32-e模式下继续引导。这段引导程序是内核的一部分，可以使用内核中的函数

请看本章代码`25/Boot.inc`。

第7\~8行，定义了AP引导程序的段基址和物理内存地址。

接下来，请看本章代码`25/AP.s`。

第12行，定义CPU的数量为4。

第16\~19行，为AP引导程序准备信息，这些信息如下表所示：

| 地址                    | 字节数 | 含义                       |
| ----------------------- | ------ | -------------------------- |
| `__AP_BOOT_ADDR + 0x8`  | 10     | GDTR                       |
| `__AP_BOOT_ADDR + 0x18` | 10     | IDTR                       |
| `__AP_BOOT_ADDR + 0x28` | 8      | AP的第二阶段引导程序的入口 |

第21\~24行，向AP广播唤醒信号。

第26\~29行，等待所有AP引导完成。这段代码的原理见下。

接下来，请看本章代码`25/APBoot.s`。

`APBoot.s`是AP的第一阶段引导程序，相当于简化版的`Mbr.s`。

第3行，跳过数据区。

第5行，使数据区对齐到`__AP_BOOT_ADDR + 0x8`地址处。注意到`jmp .__bootStart`指令的大小不会超过8字节，所以，数据区的起始地址是固定的。

第6\~13行，定义数据区。数据区已由`25/AP.s`中的`apInit`函数准备完毕。

第17\~19行，初始化段寄存器。

第21行，加载BSP已经准备好的GDTR。

第23\~42行，进入保护模式并初始化所有段寄存器。

第44\~45行，安装BSP已经准备好的PML4。

第47\~60行，进入IA32-e模式。

第66行，跳转到AP的第二阶段引导程序。

接下来，请看本章代码`25/AP.s`。

`apBoot64`函数是AP的第二阶段引导程序，其实现可以对照`Kernel.c`，如下表所示：

| BSP            | AP                                |
| -------------- | --------------------------------- |
| `printInit`    | 不需要                            |
| `intInit`      | 需要初始化LAPIC，并加载IDTR       |
| `memoryInit`   | 不需要                            |
| `taskInit`     | 需要加载TSS和IA32_GS_BASE         |
| `fsInit`       | 不需要                            |
| `keyboardInit` | 不需要                            |
| `syscallInit`  | 需要，可直接调用`syscallInit`函数 |
| `apInit`       | 不需要                            |
| `shellInit`    | 不需要                            |
| `sti`          | 需要                              |
| `for (;;)`     | 需要                              |
| `hlt`          | 需要                              |

第35\~36行，加载64位的GDTR和IDTR。

第38\~40行，计算AP的编号，将其存入R8中。

第42\~45行，计算AP的TCB地址，将其存入R9中。

第47行，初始化0特权级栈。

第49\~50行，打开LAPIC。

第51\~53行，设定LAPIC定时器。

第55\~57行，加载TSS。

第59\~63行，初始化IA32_GS_BASE。

第65行，初始化快速系统调用。

第67行，在总线锁定状态下将`apInitFlag`加1。`apInitFlag`是一个初值为1的计数器，当其值增加到`__CPU_COUNT`时，就表示所有AP均引导完毕。

第69行，打开中断。

至此，AP也能参与时钟中断，并切换到其他任务执行了。现在的任务队列中一共存在5个永不退出的任务，它们分别是：

* 4个内核任务
* 1个外壳程序

在任意时刻，这些任务被哪个CPU执行是未知的，也就是说，BSP和AP现在已经没有区别了。

第71\~74行，挂起AP。

第76\~77行，定义AP初始化计数器。

接下来，请看本章代码`25/Kernel.c`。

第24行，初始化AP。

## 25.6 优化任务切换

仅当任务队列中没有任务需要运行时，操作系统才应该启用内核任务。在多处理器操作系统中，这个优化需要解决两个问题：

1. 每个处理器都有一个内核任务，怎么找到当前处理器的内核任务？
2. 任务队列被多个处理器竞争，不能假定其在两次任务切换之间没有发生变化

当前处理器的内核任务的TCB地址可以通过IA32_GS_BASE计算出来，但这比较麻烦，请注意不能使用`lea rax, [gs:-40]`这样的指令，因为`lea`指令不会考虑段基址。更简单的方法是，在内核任务的TCB中记录其本身的地址，TCB中的`__idleTask`字段即为此用途。

请看本章代码`25/Task.hpp`。

第39、52行，初始化每个内核任务TCB中的`__idleTask`成员。

`__getIdleTask`函数用于返回TCB中的`__idleTask`成员。

第224\~229行，仅当当前任务不是内核任务时，才将其加入任务队列。

第231行，遍历整个任务队列。请注意这里的循环次数仅为估算值，由于其他处理器的存在，不能保证任务队列的长度不变。

第235\~238行，如果任务队列为空，则提前退出循环。

第248\~252行，规避当前任务回收自身内存的情况。

第265行，如果未发现需要执行的任务，则返回内核任务。

## 25.7 编译与测试

本章代码`25/Makefile`新增了`APBoot.s`和`AP.s`的编译与链接命令。

本章代码`25/Kernel.c`测试了多处理器环境下的任务切换。现在，当多次加载`Test.c`任务后，所有任务的总运行时间应明显加快。

至此，我们已经实现了一个64位多处理器操作系统。

