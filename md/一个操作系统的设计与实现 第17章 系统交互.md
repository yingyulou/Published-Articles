# 一个操作系统的设计与实现

# 第17章 系统交互

操作系统是供用户使用的，所以其需要具备与用户交互的能力，交互方式可以是命令行，图形界面，甚至是触摸屏，语音，实体按钮等。在操作系统中，实现此功能的模块被称为外壳（Shell）程序。本章将要实现外壳程序。

## 17.1 外壳程序的实现原理

我们的操作系统使用的是基于命令行的交互模式。事实上，上一章的`Test.c`已经是一个简单的外壳程序了，它唯一的功能是：读取命令行输入，然后将其打印，因此，如果对命令行输入进行解析，根据其内容调用各种操作系统内核函数，就能得到一个具有实用价值的外壳程序。

我们的外壳程序支持以下命令：

1. `l`命令，调用`fsList`函数
2. `c 文件名 起始扇区号 扇区数`命令，调用`fsCreate`函数
3. `d 文件名`命令，调用`fsDelete`函数
4. `r 文件名`命令，调用`fsLoad`函数，然后阻塞外壳程序，并等待任务退出
5. 如果命令行输入不是上述命令中的一种，则打印输入的字符串

## 17.2 实现外壳程序

请看本章代码`17/Util.hpp`。

本章新增的几个辅助函数如下所示：

* `isalnum`和`isdigit`函数与C语言标准库的同名函数等价
* `getNextStr`函数用于取得给定字符串的下一个单词
* `getNextNum`函数用于取得给定字符串的下一个整数

接下来，请看本章代码`17/Shell.hpp`。

第10行，定义了外壳程序的TCB指针。

`__parseCmd`函数用于解析命令行输入。

第14\~17行，解析`l`命令，并调用`fsList`函数。

第18\~27行，解析`c 文件名 起始扇区号 扇区数`命令，并调用`fsCreate`函数。

第28\~33行，解析`d 文件名`命令，并调用`fsDelete`函数。

第34\~42行，解析`r 文件名`命令，并调用`fsLoad`函数。然后，将外壳程序阻塞，并立即进行任务切换。

第43\~46行，如果命令行输入不属于上述情况，则打印输入的字符串。

`arenaShell`函数实现了外壳程序。

第52行，定义了命令字符串缓冲区。

第54\~59行，在循环中不断进行以下操作：

1. 打印命令提示符
2. 读取命令行输入
3. 解析输入的字符串

`shellInit`函数用于加载外壳程序，并初始化`shellTask`全局变量。外壳程序调用了文件系统以及`Util.hpp`中的函数，这些函数都是仅限0特权级使用的，所以外壳程序应加载成一个0特权级任务。读者也可以将外壳程序实现成一个3特权级任务，这就需要将其使用的所有函数都实现成系统调用。

接下来，请看本章代码`17/Task.hpp`。

第198行，当任务退出时，重新唤醒外壳程序。

接下来，请看本章代码`17/Kernel.c`。

第21行，初始化外壳程序。

## 17.3 优化任务切换

启用外壳程序后，任务队列中可能同时存在3个任务：

* 内核任务
* 外壳程序
* 测试任务

考察这三个任务可知，内核任务仅循环执行`hlt`指令，此时，如果任务队列中还有其他任务在等待执行，则`hlt`指令就是在浪费时间，因此，仅当任务队列中没有任务需要执行时，切换到内核任务才是合理的。想要实现这个优化，内核任务就始终不应该加入任务队列，而是仅作为任务切换时的备选任务。

请看本章代码`17/Task.hpp`。

第159\~162行，如果当前任务不是内核任务，则将其加入到任务队列。内核任务始终不加入任务队列。

第164行，遍历任务列表，查找等待运行的任务。

第189行，如果遍历整个任务列表都找不到等待运行的任务，则返回内核任务作为备选。

引入此优化后，读者应关注任务退出时的场景，一定要避免任务自己回收自己的情况发生。在我们的操作系统中，任务退出时会唤醒外壳程序，然后由外壳程序回收已经退出的任务，所以不存在这个问题。

## 17.4 编译与测试

启动bochs后，可以发现命令行已经开始工作。

在命令行中输入`c test 1000 100`命令，再输入`l`命令，可以发现`test`文件已经安装完毕，其对应的是`Test.c`测试程序。

在命令行中输入`r test`命令，可以发现`test`程序已经开始运行，命令行正在等待用户输入，而此时的外壳程序处于阻塞状态。输入任意字符串后回车，可以发现`test`程序在打印输入字符串后结束，外壳程序重新开始运行。

在命令行中输入`d test`命令，再输入`l`命令，可以发现`test`文件已被删除。

我们的操作系统到这里就全部实现完成了。

