# 一个操作系统的设计与实现

# 第13章 任务（四）：任务退出

在前面的两章中，我们的操作系统均不支持任务退出，所以任务不能退出。本章将要实现的是任务退出功能。

## 13.1 任务退出的实现原理

如果一个任务已经退出，它就应该从任务队列中删除。仅仅这样做是不够的，这是因为任务还持有一些内存没有释放，这包括以下两部分：

1. 任务地址空间中的页，包括3特权级栈，任务的加载地址，以及任务在运行期间申请的内存（我们的操作系统不支持此功能）
2. 任务加载时分配的页，其位于内核地址空间

回收这两部分内存都不难，但问题是，谁来回收这两部分内存？是内核，还是任务自己？

如果由内核负责回收，那么，想要回收任务地址空间中的页，就需要临时切换到任务的CR3（就像任务加载时那样）。这个方案是可行的，只是略显麻烦。感兴趣的读者可以自行尝试。

如果由任务负责回收，那么，任务地址空间中的页可以直接回收，不需要切换CR3。但内核地址空间中的页如果也由任务回收的话，将导致任务的0特权级栈立即失效，而此时，任务的回收还没有彻底结束，必然存在至少一条需要使用0特权级栈的指令，如`ret`，这条指令一旦执行，就会引发页错误。所以，这个方案是不可行的。这段描述可能会令读者感到困惑，读者不妨先跳过，读完本章后再行理解。

综上，由任务回收任务地址空间中的页比较方便，而内核中的页必须由内核回收，所以，可将任务内存的回收分为以下两个部分：

1. 任务负责回收任务地址空间中的页
2. 内核负责回收任务加载时分配的页

任务队列会在任务切换时发生变化，因此，可以在任务切换期间进行任务回收。想要知道一个任务是否需要被回收，就需要在TCB中添加任务状态字段。目前，我们的操作系统只需要两种任务状态：

* 任务就绪或正在运行
* 任务退出

任务切换时，如果发现下一个任务的状态是任务退出，就可以回收此任务的内核页，然后再次获取下一个任务。

## 13.2 实现任务退出

### 13.2.1 回收任务地址空间中的页

请看本章代码`13/Memory.hpp`。

`deallocateTaskCR3`是本章新增的函数，其用于回收任务地址空间中的页。页的回收从PDE开始，如果PDE的P位为0，就可以直接跳过这个PDE；如果PDE的P位为1，就需要进一步遍历其中的1024个PTE，如果PTE的P位为1，就需要回收PTE指向的页，最后，还要回收PDE指向的页表。

第102行，循环768次，每次考察一个PDE。768个PDE对应的是3G大小的任务地址空间。

第104行，使用第8章中的公式计算得到PDE指针。

第106行，判断PDE的P位。

第108行，遍历当前PDE中的每一个PTE。

第110行，使用第8章中的公式计算得到PTE指针。

第112行，判断PTE的P位。

第114行，从物理地址位图中删除PTE指向的页。PTE带有页属性，需要去除后才是物理地址。

第118行，从物理地址位图中删除PDE指向的页。同样的，PDE带有页属性，需要去除后才是物理地址。

### 13.2.2 添加任务状态并实现任务退出

请看本章代码`13/Task.h`。

第5\~6行，定义了两个任务状态。

接下来，请看本章代码`13/Task.hpp`。

第17行，第56行，第95行，将新任务的任务状态设为就绪。

本章的`getNextTask`函数已重新实现，用于在任务切换期间删除已退出的任务。

第160行，无限循环，不断在任务列表中寻找下一个需要运行的任务。

第162行，从任务列表中取出下一个任务。

第164行，考察新任务的任务状态。

第166\~168行，如果新任务需要运行，则返回这个任务。

第170\~172行，如果新任务已退出，则回收新任务的内核页。然后，循环将继续，且此任务不再加入任务队列。

第174\~177行，当任务状态未定义时抛出异常。

`taskExit`是本章新增的函数。这是一个系统调用，用于任务退出。

第185行，回收任务地址空间中的页。

第187行，将任务状态切换为退出。

第189行，跳转到`__taskSwitch`处继续执行。这个符号定义在本章代码`13/Int.s`中。

请看本章代码`13/Int.s`。

第64行，定义了`__taskSwitch`符号。

第197行，将`taskExit`函数安装到系统调用表中，其系统调用号为2。系统调用号1保留给后续章节使用。

接下来，请看本章代码`13/Kernel.c`。

第23行，将CPU挂起，等待外中断的唤醒。

### 13.2.3 自动退出任务

现在，2号系统调用已经安装完毕，任务应在退出时发起这个系统调用。即，任务的代码应当是这样：

```c
int main()
{
    // ...

    __asm__ __volatile__("int $0x30":: "a"(2));
}
```

然而，要求每个`main`函数都在最后加这行代码是不现实的，这段代码应在任务退出时自动执行，这就是`_start`符号存在的意义。`_start`是任务真正的入口，`main`函数是由`_start`调用的，因此，在调用`main`函数的前后，还能进行其他操作，例如：

* `main`函数的3个参数：`int main(int argc, char **argv, char **envp)`都是由`_start`传入的（我们的操作系统不支持此功能）
* `main`函数退出后，由`_start`接收其返回值，并进行任务退出

请看本章代码`13/Start.s`。

第9行，调用`main`函数。

第11\~12行，在`main`函数退出后，自动发起2号系统调用。

## 13.3 编译与测试

现在，每个任务都需要与`Start.o`共同链接，以具备自动发起2号系统调用的能力。在实际的操作系统中，含有`_start`的库会被链接器自动使用，所以，用户无需显式的写出这个库。

本章代码`13/Makefile`新增了`Start.s`的编译与链接命令。

本章使用的测试任务是`13/Test.c`。现在，测试任务可以正常退出了，不再需要无限循环。

