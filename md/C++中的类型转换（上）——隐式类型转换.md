# C++中的类型转换（上）——隐式类型转换

## 0. 引言

不同的数据在计算机内存中的存储方式不同，导致了"类型"这一抽象概念的出现。对于一个变量而言，其必须要回答三个问题：

1. 在哪可以访问到这个变量的起点？
2. 从起点向后需要读取多少内存？
3. 应该如何解析读取到的二进制数据？

上述的三个问题中，问题1，由内存地址回答，问题2和3，均由类型回答。由此可见，类型与内存地址共同构成了一个变量的完整组分。之所以不能对void *取值，也是由于无法回答问题2和3导致。

进一步的，我们可以得到一条十分重要的结论：对于两个不同类型的变量，由于其对问题2和3的答案不同，故如果将这样的两个变量直接进行运算，在绝大多数情况下都将无法产生有价值的计算结果。故在几乎所有的编程语言中都有一条重要的规定：不同类型的两个变量无法直接进行运算。

虽然不同类型的两个变量无法进行运算，但显然，我们可将其中的一个变量通过类型转换，转为与另一个变量类型一致，此时就满足"同类型变量才能进行运算"这一规定了。同时，由于某些类型转换是"理所应当"的，而另一些不是，故由此又派生出两个概念：隐式类型转换与显式类型转换。隐式类型转换指不通过专门的类型转换操作，而是通过其他规定或代码上下文隐式发生的类型转换，而显式类型转换则通过专门的类型转换操作进行转换，显式类型转换具有强制性，其将不受任何类型转换以外的因素影响，故显式类型转换又称为强制类型转换。

在C++中，类型转换是一个非常复杂的话题。本文将先从隐式类型转换入手，逐步讨论各类C++的类型转换话题。

## 1. 类型提升与算术类型转换

算术类型转换专指C++提供的各种内置算术类型之间的隐式类型转换。内置算术类型主要包括以下类型：

1. bool
2. char, signed char, unsigned char
3. short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long
4. float, double, long double
5. size_t, ptrdiff_t, nullptr_t等其他特殊类型

算术类型转换是一类不完全明确的，且与底层密切相关的隐式类型转换。其遵循以下几条主要原则：

1. 对于同类算术类型，如short与int，float与double，占用较小内存的类型将转换成另一类型。如short + int将被转换为int + int。此种类型转换称为类型提升。
2. 整形将转为浮点型。如int + double将被转换为double + double。
3. **仅当无符号类型占用的内存小于有符号类型时，无符号类型将发生类型提升从而转为有符号类型，否则，有符号类型将转为无符号类型。这是一个非常需要注意的点。**

参考以下代码：

``` Cpp
int main()
{
    unsigned short a = 1;
    unsigned b = 1;
    cout << (a > -1) << " " << (b > -1) << endl;  // 1 0!
}
```

上述代码中，-1作为int直接量而存在，由于变量a是unsigned short类型，故其将被转为int，值仍为1。但由于变量b的类型是与int同级的unsigned类型，故此时-1将被转为unsigned类型，这明显不是我们需要的结果。由此可见，当有符号类型与无符号类型（如size_t）发生混用时，一定要小心可能会发生的隐式类型转换。

## 2. 转换构造函数

### 2.1 定义转换构造函数

C++中，如果一个构造函数满足以下所有条件，则其成为一个转换构造函数：

1. 至多有一个不含默认值的形参。这主要包括以下几种情况：

- 构造函数只有一个形参
- 构造函数有不止一个形参，但只有第一形参无默认值
- 构造函数有不止一个形参，但全部形参均有默认值

2. 第一形参的类型不为类本身或其附加类型（否则此构造函数将成为拷贝构造函数或移动构造函数）

如果一个类定义了某种转换构造函数，则被定义的类型将可以通过任何类型转换方式转为当前类类型。这常见于以下几种情况：

1. 赋值时发生的隐式类型转换
2. 实参传递时发生的隐式类型转换
3. 基于static_cast的显式类型转换

参考以下代码：

``` Cpp
struct A { A (int) {} };  // 转换构造函数

void test(A) {}

int main()
{
    A _ = 0;  // 赋值时发生的隐式类型转换
    test(0);  // 实参传递时发生的隐式类型转换
}
```

上述代码中，我们为类A定义了从int到A的转换构造函数。则此时，我们即可以将一个int直接赋值给类型为A的变量，也可以直接将一个int作为实参传给类型为A的形参。这两种情况发生时，都隐式地通过转换构造函数构造了类A的一个实例。

### 2.2 阻止基于转换构造函数进行的隐式类型转换

由上文可知，当定义了一个转换构造函数后，就打通了某个其他类型向类类型进行转换的通道。此时，如果我们希望禁用基于转换构造函数进行的隐式类型转换，则需要在转换构造函数前追加explicit声明。

当一个转换构造函数被声明为explicit后，其具有以下性质：

1. 禁止一切场合下的基于转换构造函数的隐式类型转换
2. 不影响被转换类型到类类型的强制类型转换
3. 不影响对转换构造函数的正常调用

参考以下代码：

``` Cpp
struct A { explicit A (int) {} };  // explicit转换构造函数

void test(A) {}

int main()
{
    A _ = 0;            // Error！禁止赋值时发生的隐式类型转换！
    test(0);            // Error！禁止实参传递时发生的隐式类型转换！
    static_cast<A>(0);  // explicit不影响强制类型转换
    A(0);               // explicit不影响对转换构造函数的正常调用
}
```

上述代码中，我们将类A的转换构造函数声明为explicit，则此时int将不能通过赋值或实参传递的方式隐式的转换为A。但显然，explicit只是禁用了转换构造函数的隐式类型转换功能，其构造函数功能以及显式类型转换功能并不受影响。

## 3. 类型转换运算符

转换构造函数定义了其他类型向类类型的转换方案，类型转换运算符则定义了与之相反的过程：其用于定义类类型向其他类型的转换方案。当类定义了某种类型的类型转换运算符后，类类型将可以向被定义类型发生类型转换。

参考以下代码：

``` Cpp
struct A { operator int() const { return 0; } };  // 定义A -> int进行类型转换的方案

void test(int) {}

int main()
{
    test(A());  // 发生了A -> int的隐式类型转换
}
```

与转换构造函数类似，如果希望禁用隐式类型转换，则需要对类型转换运算符追加explicit声明。同样的，explicit不影响强制类型转换。

参考以下代码：

``` Cpp
struct A { explicit operator int() const { return 0; } };  // explicit类型转换运算符

void test(int) {}

int main()
{
    test(A());                    // Error！禁止A -> int的隐式类型转换
    test(static_cast<int>(A()));  // explicit不影响强制类型转换
}
```

对于类型转换运算符与explicit还有一条额外规定：operator bool()在条件表达式（这主要包括：if, while, for, ?:的条件部分）或逻辑表达式中发生的隐式类型转换将不受explicit影响。

参考以下代码：

``` Cpp
struct A { explicit operator bool() const { return true; } };  // explicit类型转换运算符

int main()
{
    if (A()) {}  // 即使operator bool()被声明为explicit，其在if中也能发生隐式类型转换
}
```

## 4. 继承类到基类的类型转换

### 4.1 静态类型与动态类型

C++的继承机制决定了这样的抽象模型：继承类 = 基类部分 + 继承类部分，这意味着每一个继承类都含有其所有基类（如果基类不止一个）的数据各一份。也就是说，对于一个继承类对象，对其基类部分进行操作显然是可行的，这主要包括：

1. 得到基类部分的数据
2. 将类型转换为基类类型（以丢失某些信息为代价）

也就是说，我们可以将一个继承类对象直接赋值给一个基类类型的变量，显然，这样的赋值建立在隐式类型转换之上，称为继承类到基类的类型转换，或称为向上类型转换。根据附加类型的不同，向上类型转换分为以下几种情况：

``` Cpp
struct A {};
struct B: A {};

int main()
{
    A a1   = B();    // 值向上转换
    A *a2  = new B;  // 指针向上转换
    A &a3  = a1;     // 左值引用向上转换
    A &&a4 = B();    // 右值引用向上转换
}
```

上述代码中，变量a1的类型是A，这是一个非指针或引用变量，故变量的内存大小就是A类对象的大小。如果对基类类型变量使用继承类对象赋值，则将强行去除继承类对象的继承类部分，而将基类部分赋值给变量。故对于a1而言，其得到的应该是一个B类对象的A类部分。即：**如果发生向上类型转换的类型是类本身，则将以丢失继承类对象的继承类部分为代价进行向上类型转换。**

事实上，此赋值操作调用了A类的合成拷贝赋值运算符，而非基于隐式类型转换。C++对于类的某些成员函数的合成操作是一个非常复杂的话题，且涉及大量与本文无关的内容，故本文不再详述。

对于变量a2-4，其类型都是A的指针或引用（也是指针），而非A的本体。由于指针本身并不与类型直接挂钩，故理论上，此类变量中真正存放的值可以是一个非A类型的数据。由此，我们引出静态类型与动态类型的概念。

C++中，一个变量声明的类型称为静态类型，而其实际存储的数据的类型称为动态类型。在绝大多数情况下，静态类型与动态类型都是必须一致的，如果不一致，将发生隐式类型转换或引发编译错误。当且仅当使用基类的指针或引用存储继承类对象时，变量的静态类型与动态类型将不一致。此时，虽然看上去发生了向上类型转换，但实际上并未发生，此过程称为动态绑定。

一个变量的静态类型，决定了由此变量能够访问到的成员名称。当静态类型是基类指针或引用时，即使变量存放的是继承类对象，也只能够访问到基类中声明的成员名称。即：**如果发生向上类型转换的类型是类的指针或引用，则将以丢失继承类部分的成员名称为代价进行向上类型转换。**但由于虚函数的存在，访问成员名称所得到的实际成员函数将不一定与静态类型保持一致，此性质是C++多态的核心。虚函数相关话题与本文无关，这里不再详述。

### 4.2 阻止向上类型转换

让我们重新思考这样一个问题：为什么继承类可以访问基类的成员？不难发现，"继承类可以访问基类成员"这一性质并不是天经地义的，因为继承类中并没有"复制粘贴"一个基类，而只有继承类本身的部分，故原则上继承类虽然继承了基类，但其本身仍然是没有能力访问基类的成员的。继承类对象之所以能够访问基类成员，是因为在进行这样的访问时，继承类的this指针通过向上类型转换操作转换成了一个基类类型的指针，然后以基类指针的身份访问到了基类的成员。

如果希望阻止这种隐式的向上类型转换呢？让我们认真考察public，protected，private这三个关键字。

按照常规的解读，这三个关键词用于限定类的用户的访问权，需要注意的是：**"类的用户"不仅指类实例，也指继承此类的类。**说明如下：

- public：当用于访问说明符时，表示对类的一切用户可见；用于继承时，表示继承时不修改基类的一切访问说明符
- protected：当用于访问说明符时，表示仅对类的继承用户可见，对类的实例用户不可见；用于继承时，表示将基类的一切public访问说明符在继承类中修改为protected
- private：当用于访问说明符时，表示对一切类的用户均不可见；用于继承时，表示将基类的一切public和protected访问说明符在继承类中修改为private

上述描述中，"将基类的xxx访问说明符在继承类中修改为xxx"是一个很奇怪且魔幻的描述，我们不禁要思考，为什么C++会给出这样的三种继承模式？又为什么要"伴随着继承修改访问说明符"呢？

如果我们从向上类型转换这一角度思考，就能得出答案：

- public：不阻止任何用户进行向上类型转换
- protected：阻止类的实例用户进行向上类型转换
- private：阻止一切用户进行向上类型转换

由此我们可知，"修改访问说明符"是一种访问说明符在继承时的作用的较为直观的理解，而其真正意义是阻止向上类型转换。

参考以下代码：

``` Cpp
struct A {};

struct B: A {};            // 不阻止任何B类的用户向A进行类型转换
struct C: protected A {};  // 阻止C类的实例用户向A进行类型转换
struct D: private A {};    // 阻止D类的一切用户向A进行类型转换

struct E: B { void test() { static_cast<A *>(this); } };  // B类的继承类用户可以向A进行类型转换
struct F: C { void test() { static_cast<A *>(this); } };  // C类的继承类用户可以向A进行类型转换
struct E: D { void test() { static_cast<A *>(this); } };  // Error！D类的继承类用户不可以向A进行类型转换

int main()
{
    static_cast<A *>(new B);  // B类的实例用户可以向A进行类型转换
    static_cast<A *>(new C);  // Error！C类的实例用户不可以向A进行类型转换
    static_cast<A *>(new D);  // Error！D类的实例用户不可以向A进行类型转换
}
```

上述代码中，类B，C，D分别以三种不同的访问说明符继承自类A，同时，我们分别为类B，C，D各定义了一个继承类用户和一个实例用户。由此可见，public继承将不阻止类的任何用户进行向上类型转换，而private继承将阻止类的一切用户进行向上类型转换，protected继承只阻止类的实例用户进行向上类型转换，但不阻止类的继承类用户进行向上类型转换。

### 4.3 多重继承与向上类型转换

对于多重继承，其向上类型转换对于同一继承层的多个基类是全面进行的。

参考以下代码：

``` Cpp
struct A { int i; };
struct B { int i; };
struct C: A, B { int i; };
struct D: A, B {};

int main()
{
    C().i;  // 访问C::i
    D().i;  // Error！存在二义性！
}
```

对于类C，由于其自身定义了变量i，故访问C类的i变量时并未发生向上类型转换。而对于类D，由于其自身没有定义变量i，故访问D类的i变量时需要在其各个基类中分别进行查找。由于编译器发现D -> A -> i与D -> B -> i这两种查找路线都是可行的，故此时编译器判定此查找存在二义性。

## 5. 其他隐式类型转换

C++中还定义了一些特殊的类型转换，以下列举出一些常见的情况：

1. 0转换为空指针：

``` Cpp
int main()
{
    int *p = 0;
}
```

2. 数组退化为指针

``` Cpp
int main()
{
    int a[10];
    int *p = a;
}
```

3. 空指针或数字0转为false，其他指针或数字转为true

``` Cpp
int main()
{
    if(nullptr) {}
    if (2) {}
}
```

4. T *转换为void *

``` Cpp
int main()
{
    void *p = new int;
}
```

**显然，不存在void \* -> T \*的隐式类型转换。**

5. 非const转换为const

``` Cpp
int main()
{
    int *a;
    const int * const b = a;
}
```

樱雨楼

2019.8 于苏州
