# 一个操作系统的设计与实现

# 第24章 多处理器（上）：多处理器同步原语

## 24.1 多处理器同步原语的实现原理

当计算机中存在不止一个CPU时，基于关中断的同步原语就失效了。这是因为每个CPU的中断是独立的，关闭一个CPU的中断并不会影响其他CPU，所以，必须找到一个被所有CPU共享的区域，才能实现多CPU间的同步原语。内存正是这样的共享区域，其可用于实现锁。

使用内存实现锁，就需要一块内存标记锁的状态，并需要判断并修改锁的状态。如果使用常规方法实现这套功能，需要的指令一定不止一条，这就陷入了循环依赖：这段指令本身也需要锁，但这段指令本身就是用于实现锁的。

想要解决这个问题，就需要使用一条指令同时判断并修改锁的状态。`xchg`指令是实现这个功能的最简单的选择，具体来说：

* 将锁初始化为0
* 加锁时，固定使用1与锁进行`xchg`。如果交换来的是0，就说明锁曾经是0，现在是1，加锁成功；如果交换来的是1，就说明锁在交换前已经是1了，加锁失败，此时，任务应阻塞
* 解锁时，`mov [锁], 0`即可

加锁是一个对效率要求很高的操作，因此，CPU提供了`cmp`指令与`xchg`指令的二合一增强版：`cmpxchg`指令。顾名思义，`cmpxchg`指令能够同时进行比较与交换操作。具体来说，`cmpxchg lhs, rhs`的行为是：比较`lhs`与`al/ax/eax/rax`，如果相等，则`mov lhs, rhs`，否则，`mov rax, lhs`，此外，比较操作会影响RFLAGS的ZF位，即`je/jne/jz/jnz`指令考察的位。`cmpxchg`指令的行为看上去比较绕，如果将其用在锁上，就可以得到一个比较具体的描述：如果将RAX设为0，RDX设为1，然后执行`cmpxchg [锁], rdx`，那么，`cmpxchg`指令会比较`[锁]`与RAX，如果相等，就说明锁是0，是可用的，于是执行`mov [锁], rdx`，将锁置1，同时修改RFLAGS的ZF位，使`je`通过，表示加锁成功；否则，如果不等，就说明锁是1，是不可用的，于是执行`mov rax, [锁]`，将RAX置1，同时修改RFLAGS的ZF位，使`jne`通过，表示加锁失败。

## 24.2 总线锁定

当内存被多个CPU同时访问时，其也需要锁，因此，CPU提供了总线锁定前缀`lock`，当使用`lock`前缀时，内存会被当前指令锁定，其他CPU不能使用内存，直至当前指令结束。

总线锁定对效率有影响，所以是不能滥用的。此外，仅有非常少的指令支持`lock`前缀，它们是：`add, adc, and, btc, btr, bts, cmpxchg, cmpxch8b, cmpxchg16b, dec, inc, neg, not, or, sbb, sub, xor, xadd, xchg`，其他指令不能使用`lock`前缀。

`xchg`被强制视为具有`lock`前缀。

## 24.3 实现自旋锁

我们的操作系统使用自旋锁进行多处理器同步。

请看本章代码`24/Lock.h`。

第5行，声明了`Lock`类型。当锁不可用时，自旋锁将进行忙等待，所以其不需要等待队列，仅需要一个整数。

接下来，请看本章代码`24/Lock.s`。

`lockInit`函数用于初始化锁，将锁置0即可。

`lockAcquire`函数用于加锁。

第17行，将RDX置1，准备执行`cmpxchg`指令。

第29\~23行，不断尝试加锁。请注意：`xor rax, rax`不能放在循环外面，这是因为`cmpxchg`指令会在加锁失败时将RAX从0改成1。

`lockRelease`函数用于解锁，将锁置0即可，其与`lockInit`函数共用函数体。

## 24.4 使用自旋锁

在我们的操作系统中，任务队列和显卡驱动会被每个CPU使用，所以是需要加锁的。

请看本章代码`24/Queue.h`。

第17行，在`Queue`中加入自旋锁。

接下来，请看本章代码`24/Queue.hpp`。

第13行，初始化锁。

第19、23、31、41、49、61行，在`Queue`的每个操作中引入锁。

接下来，请看本章代码`24/Print.hpp`。

第9行，定义了显卡驱动锁。

第72、79行，在`printStr`函数中引入锁。

第175行，初始化显卡驱动锁。

## 24.5 编译与测试

本章代码`24/Makefile`新增了`Lock.s`的编译与链接命令。

本章代码`24/Kernel.c`测试了加锁以后的任务切换和`printStr`函数。

