# 编译器实现之旅——第二章 编译器前端概观

在这一章的旅程中，我们将要深入编译器前端一探究竟。看看编译器前端到底由哪些组件组成，其分别又是在做什么。

## 1. 编译器前端的结构组成

似乎比我们想象的要简单，编译器前端仅由两个组件组成，词法分析器与语法分析器。请看下图：

```
         +----------+             +-----------+
源代码 -> | 词法分析器 | -> 记号流 -> | 语法分析器 | -> 抽象语法树
         +----------+             +-----------+
```

## 2. 什么是词法分析器

词法分析器（Lexer）是"前端中的前端"。作为整个编译器的第一个组件，词法分析器负责阅读并分割源代码，将编译器看来"胡子连着辫子"的源代码，分割为一个个的记号（Token）流，同时，词法分析器还负责识别并归类每一个记号。当然了，一旦词法分析器发现了一个不应该出现的字符，其就会产生一个错误信息。词法分析器的工作内容如下图所示：

```
         +----------+
源代码 -> | 词法分析器 | -> (记号的类别, 记号字符串), (记号的类别, 记号字符串), ...
         +----------+
```

我们将在词法分析器的相关章节进一步讲述词法分析器的故事。

## 3. 什么是语法分析器

源代码在经过词法分析器无情的切割后，就到了语法分析器该上场的时候了。不难发现，词法分析器所做的工作虽然很厉害，但其终究只是完成了类似于数据清洗的工作，输出的只是线性的记号流，这就像一大段没有章节，甚至没有标点的文字，根本没法阅读。

语法分析器利用词法分析器的工作成果，将线性的，扁平的记号流，根据语法规则重新组织为一棵立体的巨大的树，这就是抽象语法树（AST）。抽象语法树在整个编译器中起着举足轻重的地位，其是整个编译器后端都很喜欢，并需要不断访问的一种数据结构。语法分析器的工作内容如下图所示：

```
                                                     +-----------+
(记号的类别, 记号字符串), (记号的 类别, 记号字符串), ... -> | 语法分析器 | -> 抽象语法树
                                                     +-----------+
```

我们将在语法分析器的相关章节进一步讲述语法分析器的故事。

接下来，就让我们来看看这"前端中的前端"：词法分析器，是怎么实现的吧。请看下一章：《实现词法分析器前的准备》。



上一章：[编译器实现之旅——第一章 编译器概观](编译器实现之旅——第一章%20编译器概观.md)

下一章：[编译器实现之旅——第三章 实现词法分析器前的准备](编译器实现之旅——第三章%20实现词法分析器前的准备.md)
